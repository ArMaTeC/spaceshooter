{"version":3,"file":"babylon.glTF2Serializer.min.js","mappings":"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","sources":["webpack://SERIALIZERS/webpack/universalModuleDefinition","webpack://SERIALIZERS/webpack/runtime/create fake namespace object","webpack://SERIALIZERS/external umd {\"root\":\"BABYLON\",\"commonjs\":\"babylonjs\",\"commonjs2\":\"babylonjs\",\"amd\":\"babylonjs\"}","webpack://SERIALIZERS/webpack/bootstrap","webpack://SERIALIZERS/webpack/runtime/define property getters","webpack://SERIALIZERS/webpack/runtime/global","webpack://SERIALIZERS/webpack/runtime/hasOwnProperty shorthand","webpack://SERIALIZERS/webpack/runtime/make namespace object","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/glTFFileExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFData.ts","webpack://SERIALIZERS/../../../../node_modules/tslib/tslib.es6.mjs","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFMaterialExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFUtilities.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/dataWriter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/bufferManager.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFAnimation.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFMorphTargetsUtilities.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFExporter.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/glTFSerializer.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_mesh_gpu_instancing.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_draco_mesh_compression.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_lights_punctual.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_anisotropy.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_clearcoat.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_diffuse_transmission.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_dispersion.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_emissive_strength.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_ior.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_iridescence.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_sheen.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_specular.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_transmission.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_unlit.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_materials_volume.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/EXT_materials_diffuse_roughness.ts","webpack://SERIALIZERS/../../../dev/serializers/src/glTF/2.0/Extensions/KHR_texture_transform.ts","webpack://SERIALIZERS/../../../lts/serializers/src/legacy/legacy-glTF2Serializer.ts","webpack://SERIALIZERS/./src/glTF2.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"babylonjs\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"babylonjs-serializers\", [\"babylonjs\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"babylonjs-serializers\"] = factory(require(\"babylonjs\"));\n\telse\n\t\troot[\"SERIALIZERS\"] = factory(root[\"BABYLON\"]);\n})((typeof self !== \"undefined\" ? self : typeof global !== \"undefined\" ? global : this), (__WEBPACK_EXTERNAL_MODULE__597__) => {\nreturn ","var getProto = Object.getPrototypeOf ? (obj) => (Object.getPrototypeOf(obj)) : (obj) => (obj.__proto__);\nvar leafPrototypes;\n// create a fake namespace object\n// mode & 1: value is a module id, require it\n// mode & 2: merge all properties of value into the ns\n// mode & 4: return value when already ns object\n// mode & 16: return value when it's Promise-like\n// mode & 8|1: behave like require\n__webpack_require__.t = function(value, mode) {\n\tif(mode & 1) value = this(value);\n\tif(mode & 8) return value;\n\tif(typeof value === 'object' && value) {\n\t\tif((mode & 4) && value.__esModule) return value;\n\t\tif((mode & 16) && typeof value.then === 'function') return value;\n\t}\n\tvar ns = Object.create(null);\n\t__webpack_require__.r(ns);\n\tvar def = {};\n\tleafPrototypes = leafPrototypes || [null, getProto({}), getProto([]), getProto(getProto)];\n\tfor(var current = mode & 2 && value; typeof current == 'object' && !~leafPrototypes.indexOf(current); current = getProto(current)) {\n\t\tObject.getOwnPropertyNames(current).forEach((key) => (def[key] = () => (value[key])));\n\t}\n\tdef['default'] = () => (value);\n\t__webpack_require__.d(ns, def);\n\treturn ns;\n};","module.exports = __WEBPACK_EXTERNAL_MODULE__597__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/** @internal */\r\n// eslint-disable-next-line no-var, @typescript-eslint/naming-convention\r\nexport var __IGLTFExporterExtension = 0; // I am here to allow dts to be created\r\n\r\n/**\r\n * Interface for extending the exporter\r\n * @internal\r\n */\r\nexport interface IGLTFExporterExtension {\r\n    /**\r\n     * The name of this extension\r\n     */\r\n    readonly name: string;\r\n    /**\r\n     * Defines whether this extension is enabled\r\n     */\r\n    enabled: boolean;\r\n\r\n    /**\r\n     * Defines whether this extension is required\r\n     */\r\n    required: boolean;\r\n}\r\n","import { GetMimeType } from \"core/Misc/fileTools\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Class for holding and downloading glTF file data\r\n */\r\nexport class GLTFData {\r\n    /**\r\n     * Object which contains the file name as the key and its data as the value\r\n     */\r\n    public readonly files: { [fileName: string]: string | Blob } = {};\r\n\r\n    /**\r\n     * @deprecated Use files instead\r\n     */\r\n    public get glTFFiles() {\r\n        return this.files;\r\n    }\r\n\r\n    /**\r\n     * Downloads the glTF data as files based on their names and data\r\n     */\r\n    public downloadFiles(): void {\r\n        for (const key in this.files) {\r\n            const value = this.files[key];\r\n            const blob = new Blob([value], { type: GetMimeType(key) });\r\n            Tools.Download(blob, key);\r\n        }\r\n    }\r\n}\r\n","/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nexport function __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null)\n      throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nexport var __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nexport function __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nexport function __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nexport function __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\n  var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\n  var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === \"accessor\") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === \"field\") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nexport function __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nexport function __propKey(x) {\n  return typeof x === \"symbol\" ? x : \"\".concat(x);\n};\n\nexport function __setFunctionName(f, name, prefix) {\n  if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\n  return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\n};\n\nexport function __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nexport function __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nexport function __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === \"function\" ? Iterator : Object).prototype);\n  return g.next = verb(0), g[\"throw\"] = verb(1), g[\"return\"] = verb(2), typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError(\"Generator is already executing.\");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nexport function __exportStar(m, o) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nexport function __values(o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n}\n\nexport function __read(o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i[\"return\"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nexport function __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nexport function __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nexport function __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nexport function __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nexport function __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume(\"next\", value); }\n  function reject(value) { resume(\"throw\", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nexport function __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nexport function __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nexport function __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n  o[\"default\"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nexport function __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== \"default\") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nexport function __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n  return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n  if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n  if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n  return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nexport function __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\n  return typeof state === \"function\" ? receiver === state : state.has(receiver);\n}\n\nexport function __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== \"object\" && typeof value !== \"function\") throw new TypeError(\"Object expected.\");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError(\"Symbol.asyncDispose is not defined.\");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError(\"Symbol.dispose is not defined.\");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== \"function\") throw new TypeError(\"Object not disposable.\");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n\nexport function __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, \"An error was suppressed during disposal.\") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nexport function __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === \"string\" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? \".jsx\" : \".js\" : d && (!ext || !cm) ? m : (d + ext + \".\" + cm.toLowerCase() + \"js\");\n      });\n  }\n  return path;\n}\n\nexport default {\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n};\n","/* eslint-disable @typescript-eslint/prefer-promise-reject-errors */\r\n/* eslint-disable github/no-then */\r\n/* eslint-disable babylonjs/available */\r\n\r\nimport type { ITextureInfo, IMaterial, IMaterialPbrMetallicRoughness, IMaterialOcclusionTextureInfo, ISampler, IImage } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType, MaterialAlphaMode, TextureMagFilter, TextureMinFilter, TextureWrapMode } from \"babylonjs-gltf2interface\";\r\n\r\nimport type { Nullable } from \"core/types\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { Scalar } from \"core/Maths/math.scalar\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { GetTextureDataAsync, TextureTools } from \"core/Misc/textureTools\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\r\n\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport type { GLTFExporter } from \"./glTFExporter\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { DumpTools } from \"core/Misc/dumpTools\";\r\n\r\nimport type { Material } from \"core/Materials/material\";\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport { SpecularPowerToRoughness } from \"core/Helpers/materialConversionHelper\";\r\n\r\nconst Epsilon = 1e-6;\r\nconst DielectricSpecular = new Color3(0.04, 0.04, 0.04);\r\nconst MaxSpecularPower = 1024;\r\nconst White = Color3.White();\r\nconst Black = Color3.Black();\r\n\r\n/**\r\n * Interface for storing specular glossiness factors\r\n * @internal\r\n */\r\ninterface IPBRSpecularGlossiness {\r\n    /**\r\n     * Represents the linear diffuse factors of the material\r\n     */\r\n    diffuseColor: Color3;\r\n    specularColor: Color3;\r\n    glossiness: number;\r\n}\r\n\r\ninterface IPBRMetallicRoughness {\r\n    baseColor: Color3;\r\n    metallic: Nullable<number>;\r\n    roughness: Nullable<number>;\r\n    metallicRoughnessTextureData?: Nullable<ArrayBuffer>;\r\n    baseColorTextureData?: Nullable<ArrayBuffer>;\r\n}\r\n\r\nfunction GetFileExtensionFromMimeType(mimeType: ImageMimeType): string {\r\n    switch (mimeType) {\r\n        case ImageMimeType.JPEG:\r\n            return \".jpg\";\r\n        case ImageMimeType.PNG:\r\n            return \".png\";\r\n        case ImageMimeType.WEBP:\r\n            return \".webp\";\r\n        case ImageMimeType.AVIF:\r\n            return \".avif\";\r\n    }\r\n}\r\n\r\nfunction IsCompressedTextureFormat(format: number): boolean {\r\n    switch (format) {\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:\r\n        case Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}\r\n\r\n/**\r\n * Computes the metallic factor from specular glossiness values.\r\n * @param diffuse diffused value\r\n * @param specular specular value\r\n * @param oneMinusSpecularStrength one minus the specular strength\r\n * @returns metallic value\r\n * @internal\r\n */\r\nexport function _SolveMetallic(diffuse: number, specular: number, oneMinusSpecularStrength: number): number {\r\n    if (specular < DielectricSpecular.r) {\r\n        DielectricSpecular;\r\n        return 0;\r\n    }\r\n\r\n    const a = DielectricSpecular.r;\r\n    const b = (diffuse * oneMinusSpecularStrength) / (1.0 - DielectricSpecular.r) + specular - 2.0 * DielectricSpecular.r;\r\n    const c = DielectricSpecular.r - specular;\r\n    const d = b * b - 4.0 * a * c;\r\n    return Scalar.Clamp((-b + Math.sqrt(d)) / (2.0 * a), 0, 1);\r\n}\r\n\r\n/**\r\n * Computes the metallic/roughness factors from a Standard Material.\r\n * @internal\r\n */\r\nexport function _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial: StandardMaterial): IMaterialPbrMetallicRoughness {\r\n    const diffuse = babylonStandardMaterial.diffuseColor.toLinearSpace(babylonStandardMaterial.getScene().getEngine().useExactSrgbConversions).scale(0.5);\r\n    const opacity = babylonStandardMaterial.alpha;\r\n    const specularPower = Scalar.Clamp(babylonStandardMaterial.specularPower, 0, MaxSpecularPower);\r\n\r\n    const roughness = SpecularPowerToRoughness(specularPower);\r\n\r\n    const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {\r\n        baseColorFactor: [diffuse.r, diffuse.g, diffuse.b, opacity],\r\n        metallicFactor: 0,\r\n        roughnessFactor: roughness,\r\n    };\r\n\r\n    return glTFPbrMetallicRoughness;\r\n}\r\n\r\n/**\r\n * Sets the glTF alpha mode to a glTF material from the Babylon Material\r\n * @param glTFMaterial glTF material\r\n * @param babylonMaterial Babylon material\r\n */\r\nfunction SetAlphaMode(glTFMaterial: IMaterial, babylonMaterial: Material & { alphaCutOff?: number }): void {\r\n    if (babylonMaterial.needAlphaBlending()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.BLEND;\r\n    } else if (babylonMaterial.needAlphaTesting()) {\r\n        glTFMaterial.alphaMode = MaterialAlphaMode.MASK;\r\n        glTFMaterial.alphaCutoff = babylonMaterial.alphaCutOff;\r\n    }\r\n}\r\n\r\nfunction CreateWhiteTexture(width: number, height: number, scene: Scene): Texture {\r\n    const data = new Uint8Array(width * height * 4);\r\n\r\n    for (let i = 0; i < data.length; i = i + 4) {\r\n        data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0xff;\r\n    }\r\n\r\n    const rawTexture = RawTexture.CreateRGBATexture(data, width, height, scene);\r\n\r\n    return rawTexture;\r\n}\r\n\r\nfunction ConvertPixelArrayToFloat32(pixels: ArrayBufferView): Float32Array {\r\n    if (pixels instanceof Uint8Array) {\r\n        const length = pixels.length;\r\n        const buffer = new Float32Array(pixels.length);\r\n        for (let i = 0; i < length; ++i) {\r\n            buffer[i] = pixels[i] / 255;\r\n        }\r\n        return buffer;\r\n    } else if (pixels instanceof Float32Array) {\r\n        return pixels;\r\n    } else {\r\n        throw new Error(\"Unsupported pixel format!\");\r\n    }\r\n}\r\n\r\n/**\r\n * Utility methods for working with glTF material conversion properties.\r\n * @internal\r\n */\r\nexport class GLTFMaterialExporter {\r\n    // Mapping to store textures\r\n    private _textureMap = new Map<BaseTexture, ITextureInfo>();\r\n\r\n    // Mapping of internal textures to images to avoid exporting duplicate images\r\n    private _internalTextureToImage: { [uniqueId: number]: { [mimeType: string]: Promise<number> } } = {};\r\n\r\n    constructor(private readonly _exporter: GLTFExporter) {}\r\n\r\n    public getTextureInfo(babylonTexture: Nullable<BaseTexture>): Nullable<ITextureInfo> {\r\n        return babylonTexture ? (this._textureMap.get(babylonTexture) ?? null) : null;\r\n    }\r\n\r\n    public async exportStandardMaterialAsync(babylonStandardMaterial: StandardMaterial, mimeType: ImageMimeType, hasUVs: boolean): Promise<number> {\r\n        const pbrMetallicRoughness = _ConvertToGLTFPBRMetallicRoughness(babylonStandardMaterial);\r\n\r\n        const material: IMaterial = { name: babylonStandardMaterial.name };\r\n        if (babylonStandardMaterial.backFaceCulling != null && !babylonStandardMaterial.backFaceCulling) {\r\n            if (!babylonStandardMaterial.twoSidedLighting) {\r\n                Tools.Warn(babylonStandardMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            material.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const diffuseTexture = babylonStandardMaterial.diffuseTexture;\r\n            if (diffuseTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(diffuseTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            pbrMetallicRoughness.baseColorTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const bumpTexture = babylonStandardMaterial.bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.normalTexture = textureInfo;\r\n                            if (bumpTexture.level !== 1) {\r\n                                material.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonStandardMaterial.emissiveTexture;\r\n            if (emissiveTexture) {\r\n                material.emissiveFactor = [1.0, 1.0, 1.0];\r\n\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            material.emissiveTexture = textureInfo;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonStandardMaterial.ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture, mimeType).then((textureInfo) => {\r\n                        if (textureInfo) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: textureInfo.index,\r\n                            };\r\n                            material.occlusionTexture = occlusionTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonStandardMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.alpha < 1.0 || babylonStandardMaterial.opacityTexture) {\r\n            if (babylonStandardMaterial.alphaMode === Constants.ALPHA_COMBINE) {\r\n                material.alphaMode = MaterialAlphaMode.BLEND;\r\n            } else {\r\n                Tools.Warn(babylonStandardMaterial.name + \": glTF 2.0 does not support alpha mode: \" + babylonStandardMaterial.alphaMode.toString());\r\n            }\r\n        }\r\n\r\n        if (babylonStandardMaterial.emissiveColor && !babylonStandardMaterial.emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            material.emissiveFactor = babylonStandardMaterial.emissiveColor.asArray();\r\n        }\r\n\r\n        material.pbrMetallicRoughness = pbrMetallicRoughness;\r\n        SetAlphaMode(material, babylonStandardMaterial);\r\n\r\n        await this._finishMaterialAsync(material, babylonStandardMaterial, mimeType);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(material);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _finishMaterialAsync(glTFMaterial: IMaterial, babylonMaterial: Material, mimeType: ImageMimeType): Promise<void> {\r\n        const textures = this._exporter._extensionsPostExportMaterialAdditionalTextures(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n\r\n        const promises: Array<Promise<Nullable<ITextureInfo>>> = [];\r\n\r\n        for (const texture of textures) {\r\n            promises.push(this.exportTextureAsync(texture, mimeType));\r\n        }\r\n\r\n        await Promise.all(promises);\r\n\r\n        await this._exporter._extensionsPostExportMaterialAsync(\"exportMaterial\", glTFMaterial, babylonMaterial);\r\n    }\r\n\r\n    private async _getImageDataAsync(buffer: Uint8Array | Float32Array, width: number, height: number, mimeType: ImageMimeType): Promise<ArrayBuffer> {\r\n        const textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\r\n\r\n        const hostingScene = this._exporter._babylonScene;\r\n        const engine = hostingScene.getEngine();\r\n\r\n        // Create a temporary texture with the texture buffer data\r\n        const tempTexture = engine.createRawTexture(buffer, width, height, Constants.TEXTUREFORMAT_RGBA, false, true, Texture.NEAREST_SAMPLINGMODE, null, textureType);\r\n\r\n        engine.isWebGPU ? await import(\"core/ShadersWGSL/pass.fragment\") : await import(\"core/Shaders/pass.fragment\");\r\n        await TextureTools.ApplyPostProcess(\"pass\", tempTexture, hostingScene, textureType, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTUREFORMAT_RGBA);\r\n\r\n        const data = await engine._readTexturePixels(tempTexture, width, height);\r\n\r\n        return (await DumpTools.DumpDataAsync(width, height, data, mimeType, undefined, true, true)) as ArrayBuffer;\r\n    }\r\n\r\n    /**\r\n     * Resizes the two source textures to the same dimensions.  If a texture is null, a default white texture is generated.  If both textures are null, returns null\r\n     * @param texture1 first texture to resize\r\n     * @param texture2 second texture to resize\r\n     * @param scene babylonjs scene\r\n     * @returns resized textures or null\r\n     */\r\n    private _resizeTexturesToSameDimensions(texture1: Nullable<BaseTexture>, texture2: Nullable<BaseTexture>, scene: Scene): { texture1: BaseTexture; texture2: BaseTexture } {\r\n        const texture1Size = texture1 ? texture1.getSize() : { width: 0, height: 0 };\r\n        const texture2Size = texture2 ? texture2.getSize() : { width: 0, height: 0 };\r\n        let resizedTexture1: BaseTexture;\r\n        let resizedTexture2: BaseTexture;\r\n\r\n        if (texture1Size.width < texture2Size.width) {\r\n            if (texture1 && texture1 instanceof Texture) {\r\n                resizedTexture1 = TextureTools.CreateResizedCopy(texture1, texture2Size.width, texture2Size.height, true);\r\n            } else {\r\n                resizedTexture1 = CreateWhiteTexture(texture2Size.width, texture2Size.height, scene);\r\n            }\r\n            resizedTexture2 = texture2!;\r\n        } else if (texture1Size.width > texture2Size.width) {\r\n            if (texture2 && texture2 instanceof Texture) {\r\n                resizedTexture2 = TextureTools.CreateResizedCopy(texture2, texture1Size.width, texture1Size.height, true);\r\n            } else {\r\n                resizedTexture2 = CreateWhiteTexture(texture1Size.width, texture1Size.height, scene);\r\n            }\r\n            resizedTexture1 = texture1!;\r\n        } else {\r\n            resizedTexture1 = texture1!;\r\n            resizedTexture2 = texture2!;\r\n        }\r\n\r\n        return {\r\n            texture1: resizedTexture1!,\r\n            texture2: resizedTexture2!,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Convert Specular Glossiness Textures to Metallic Roughness\r\n     * See link below for info on the material conversions from PBR Metallic/Roughness and Specular/Glossiness\r\n     * @see https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness/examples/convert-between-workflows-bjs/js/babylon.pbrUtilities.js\r\n     * @param diffuseTexture texture used to store diffuse information\r\n     * @param specularGlossinessTexture texture used to store specular and glossiness information\r\n     * @param factors specular glossiness material factors\r\n     * @param mimeType the mime type to use for the texture\r\n     * @returns pbr metallic roughness interface or null\r\n     */\r\n    private async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(\r\n        diffuseTexture: Nullable<BaseTexture>,\r\n        specularGlossinessTexture: Nullable<BaseTexture>,\r\n        factors: IPBRSpecularGlossiness,\r\n        mimeType: ImageMimeType\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises = new Array<Promise<void>>();\r\n        if (!(diffuseTexture || specularGlossinessTexture)) {\r\n            return await Promise.reject(\"diffuse and specular glossiness textures are not defined!\");\r\n        }\r\n\r\n        const scene: Nullable<Scene> = diffuseTexture ? diffuseTexture.getScene() : specularGlossinessTexture ? specularGlossinessTexture.getScene() : null;\r\n        if (scene) {\r\n            const resizedTextures = this._resizeTexturesToSameDimensions(diffuseTexture, specularGlossinessTexture, scene);\r\n\r\n            const diffuseSize = resizedTextures.texture1?.getSize();\r\n\r\n            let diffuseBuffer: Float32Array;\r\n            let specularGlossinessBuffer: Float32Array;\r\n\r\n            const width = diffuseSize.width;\r\n            const height = diffuseSize.height;\r\n\r\n            const diffusePixels = await resizedTextures.texture1.readPixels();\r\n            const specularPixels = await resizedTextures.texture2.readPixels();\r\n\r\n            if (diffusePixels) {\r\n                diffuseBuffer = ConvertPixelArrayToFloat32(diffusePixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from diffuse texture!\");\r\n            }\r\n            if (specularPixels) {\r\n                specularGlossinessBuffer = ConvertPixelArrayToFloat32(specularPixels);\r\n            } else {\r\n                return await Promise.reject(\"Failed to retrieve pixels from specular glossiness texture!\");\r\n            }\r\n\r\n            const byteLength = specularGlossinessBuffer.byteLength;\r\n\r\n            const metallicRoughnessBuffer = new Uint8Array(byteLength);\r\n            const baseColorBuffer = new Uint8Array(byteLength);\r\n\r\n            const strideSize = 4;\r\n            const maxBaseColor = Black;\r\n            let maxMetallic = 0;\r\n            let maxRoughness = 0;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const offset = (width * h + w) * strideSize;\r\n\r\n                    const diffuseColor = new Color3(diffuseBuffer[offset], diffuseBuffer[offset + 1], diffuseBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.diffuseColor);\r\n                    const specularColor = new Color3(specularGlossinessBuffer[offset], specularGlossinessBuffer[offset + 1], specularGlossinessBuffer[offset + 2])\r\n                        .toLinearSpace(scene.getEngine().useExactSrgbConversions)\r\n                        .multiply(factors.specularColor);\r\n                    const glossiness = specularGlossinessBuffer[offset + 3] * factors.glossiness;\r\n\r\n                    const specularGlossiness: IPBRSpecularGlossiness = {\r\n                        diffuseColor: diffuseColor,\r\n                        specularColor: specularColor,\r\n                        glossiness: glossiness,\r\n                    };\r\n\r\n                    const metallicRoughness = this._convertSpecularGlossinessToMetallicRoughness(specularGlossiness);\r\n                    maxBaseColor.r = Math.max(maxBaseColor.r, metallicRoughness.baseColor.r);\r\n                    maxBaseColor.g = Math.max(maxBaseColor.g, metallicRoughness.baseColor.g);\r\n                    maxBaseColor.b = Math.max(maxBaseColor.b, metallicRoughness.baseColor.b);\r\n                    maxMetallic = Math.max(maxMetallic, metallicRoughness.metallic!);\r\n                    maxRoughness = Math.max(maxRoughness, metallicRoughness.roughness!);\r\n\r\n                    baseColorBuffer[offset] = metallicRoughness.baseColor.r * 255;\r\n                    baseColorBuffer[offset + 1] = metallicRoughness.baseColor.g * 255;\r\n                    baseColorBuffer[offset + 2] = metallicRoughness.baseColor.b * 255;\r\n                    baseColorBuffer[offset + 3] = resizedTextures.texture1.hasAlpha ? diffuseBuffer[offset + 3] * 255 : 255;\r\n\r\n                    metallicRoughnessBuffer[offset] = 0;\r\n                    metallicRoughnessBuffer[offset + 1] = metallicRoughness.roughness! * 255;\r\n                    metallicRoughnessBuffer[offset + 2] = metallicRoughness.metallic! * 255;\r\n                    metallicRoughnessBuffer[offset + 3] = 255;\r\n                }\r\n            }\r\n\r\n            // Retrieves the metallic roughness factors from the maximum texture values.\r\n            const metallicRoughnessFactors: IPBRMetallicRoughness = {\r\n                baseColor: maxBaseColor,\r\n                metallic: maxMetallic,\r\n                roughness: maxRoughness,\r\n            };\r\n\r\n            let writeOutMetallicRoughnessTexture = false;\r\n            let writeOutBaseColorTexture = false;\r\n\r\n            for (let h = 0; h < height; ++h) {\r\n                for (let w = 0; w < width; ++w) {\r\n                    const destinationOffset = (width * h + w) * strideSize;\r\n\r\n                    baseColorBuffer[destinationOffset] /= metallicRoughnessFactors.baseColor.r > Epsilon ? metallicRoughnessFactors.baseColor.r : 1;\r\n                    baseColorBuffer[destinationOffset + 1] /= metallicRoughnessFactors.baseColor.g > Epsilon ? metallicRoughnessFactors.baseColor.g : 1;\r\n                    baseColorBuffer[destinationOffset + 2] /= metallicRoughnessFactors.baseColor.b > Epsilon ? metallicRoughnessFactors.baseColor.b : 1;\r\n\r\n                    const linearBaseColorPixel = Color3.FromInts(\r\n                        baseColorBuffer[destinationOffset],\r\n                        baseColorBuffer[destinationOffset + 1],\r\n                        baseColorBuffer[destinationOffset + 2]\r\n                    );\r\n                    const sRGBBaseColorPixel = linearBaseColorPixel.toGammaSpace(scene.getEngine().useExactSrgbConversions);\r\n                    baseColorBuffer[destinationOffset] = sRGBBaseColorPixel.r * 255;\r\n                    baseColorBuffer[destinationOffset + 1] = sRGBBaseColorPixel.g * 255;\r\n                    baseColorBuffer[destinationOffset + 2] = sRGBBaseColorPixel.b * 255;\r\n\r\n                    if (!sRGBBaseColorPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutBaseColorTexture = true;\r\n                    }\r\n\r\n                    metallicRoughnessBuffer[destinationOffset + 1] /= metallicRoughnessFactors.roughness! > Epsilon ? metallicRoughnessFactors.roughness! : 1;\r\n                    metallicRoughnessBuffer[destinationOffset + 2] /= metallicRoughnessFactors.metallic! > Epsilon ? metallicRoughnessFactors.metallic! : 1;\r\n\r\n                    const metallicRoughnessPixel = Color3.FromInts(255, metallicRoughnessBuffer[destinationOffset + 1], metallicRoughnessBuffer[destinationOffset + 2]);\r\n\r\n                    if (!metallicRoughnessPixel.equalsWithEpsilon(White, Epsilon)) {\r\n                        writeOutMetallicRoughnessTexture = true;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (writeOutMetallicRoughnessTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(metallicRoughnessBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.metallicRoughnessTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n            if (writeOutBaseColorTexture) {\r\n                promises.push(\r\n                    this._getImageDataAsync(baseColorBuffer, width, height, mimeType).then((data) => {\r\n                        metallicRoughnessFactors.baseColorTextureData = data;\r\n                    })\r\n                );\r\n            }\r\n\r\n            return await Promise.all(promises).then(() => {\r\n                return metallicRoughnessFactors;\r\n            });\r\n        } else {\r\n            return await Promise.reject(\"_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts specular glossiness material properties to metallic roughness\r\n     * @param specularGlossiness interface with specular glossiness material properties\r\n     * @returns interface with metallic roughness material properties\r\n     */\r\n    private _convertSpecularGlossinessToMetallicRoughness(specularGlossiness: IPBRSpecularGlossiness): IPBRMetallicRoughness {\r\n        const diffusePerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.diffuseColor);\r\n        const specularPerceivedBrightness = this._getPerceivedBrightness(specularGlossiness.specularColor);\r\n        const oneMinusSpecularStrength = 1 - this._getMaxComponent(specularGlossiness.specularColor);\r\n        const metallic = _SolveMetallic(diffusePerceivedBrightness, specularPerceivedBrightness, oneMinusSpecularStrength);\r\n        const baseColorFromDiffuse = specularGlossiness.diffuseColor.scale(oneMinusSpecularStrength / (1.0 - DielectricSpecular.r) / Math.max(1 - metallic));\r\n        const baseColorFromSpecular = specularGlossiness.specularColor.subtract(DielectricSpecular.scale(1 - metallic)).scale(1 / Math.max(metallic));\r\n        let baseColor = Color3.Lerp(baseColorFromDiffuse, baseColorFromSpecular, metallic * metallic);\r\n        baseColor = baseColor.clampToRef(0, 1, baseColor);\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: baseColor,\r\n            metallic: metallic,\r\n            roughness: 1 - specularGlossiness.glossiness,\r\n        };\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Calculates the surface reflectance, independent of lighting conditions\r\n     * @param color Color source to calculate brightness from\r\n     * @returns number representing the perceived brightness, or zero if color is undefined\r\n     */\r\n    private _getPerceivedBrightness(color: Color3): number {\r\n        if (color) {\r\n            return Math.sqrt(0.299 * color.r * color.r + 0.587 * color.g * color.g + 0.114 * color.b * color.b);\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the maximum color component value\r\n     * @param color\r\n     * @returns maximum color component value, or zero if color is null or undefined\r\n     */\r\n    private _getMaxComponent(color: Color3): number {\r\n        if (color) {\r\n            return Math.max(color.r, Math.max(color.g, color.b));\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Metallic/Roughness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param glTFPbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertMetalRoughFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const promises: Promise<void>[] = [];\r\n\r\n        const metallicRoughness: IPBRMetallicRoughness = {\r\n            baseColor: babylonPBRMaterial._albedoColor,\r\n            metallic: babylonPBRMaterial._metallic,\r\n            roughness: babylonPBRMaterial._roughness,\r\n        };\r\n\r\n        if (hasUVs) {\r\n            const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n            if (albedoTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(babylonPBRMaterial._albedoTexture!, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.baseColorTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n            const metallicTexture = babylonPBRMaterial._metallicTexture;\r\n            if (metallicTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(metallicTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFPbrMetallicRoughness.metallicRoughnessTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n        }\r\n\r\n        if (promises.length > 0) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n            await Promise.all(promises);\r\n        }\r\n\r\n        return metallicRoughness;\r\n    }\r\n\r\n    private _getTextureSampler(texture: Nullable<BaseTexture>): ISampler {\r\n        const sampler: ISampler = {};\r\n        if (!texture || !(texture instanceof Texture)) {\r\n            return sampler;\r\n        }\r\n\r\n        const wrapS = this._getGLTFTextureWrapMode(texture.wrapU);\r\n        if (wrapS !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapS = wrapS;\r\n        }\r\n\r\n        const wrapT = this._getGLTFTextureWrapMode(texture.wrapV);\r\n        if (wrapT !== TextureWrapMode.REPEAT) {\r\n            sampler.wrapT = wrapT;\r\n        }\r\n\r\n        switch (texture.samplingMode) {\r\n            case Texture.LINEAR_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPLINEAR: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_LINEAR;\r\n                break;\r\n            }\r\n            case Texture.LINEAR_LINEAR_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.LINEAR;\r\n                sampler.minFilter = TextureMinFilter.LINEAR_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n            case Texture.NEAREST_NEAREST_MIPNEAREST: {\r\n                sampler.magFilter = TextureMagFilter.NEAREST;\r\n                sampler.minFilter = TextureMinFilter.NEAREST_MIPMAP_NEAREST;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return sampler;\r\n    }\r\n\r\n    private _getGLTFTextureWrapMode(wrapMode: number): TextureWrapMode {\r\n        switch (wrapMode) {\r\n            case Texture.WRAP_ADDRESSMODE: {\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n            case Texture.CLAMP_ADDRESSMODE: {\r\n                return TextureWrapMode.CLAMP_TO_EDGE;\r\n            }\r\n            case Texture.MIRROR_ADDRESSMODE: {\r\n                return TextureWrapMode.MIRRORED_REPEAT;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported Texture Wrap Mode ${wrapMode}!`);\r\n                return TextureWrapMode.REPEAT;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert a PBRMaterial (Specular/Glossiness) to Metallic Roughness factors\r\n     * @param babylonPBRMaterial BJS PBR Metallic Roughness Material\r\n     * @param mimeType mime type to use for the textures\r\n     * @param pbrMetallicRoughness glTF PBR Metallic Roughness interface\r\n     * @param hasUVs specifies if texture coordinates are present on the submesh to determine if textures should be applied\r\n     * @returns glTF PBR Metallic Roughness factors\r\n     */\r\n    private async _convertSpecGlossFactorsToMetallicRoughnessAsync(\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        mimeType: ImageMimeType,\r\n        pbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        hasUVs: boolean\r\n    ): Promise<IPBRMetallicRoughness> {\r\n        const specGloss: IPBRSpecularGlossiness = {\r\n            diffuseColor: babylonPBRMaterial._albedoColor,\r\n            specularColor: babylonPBRMaterial._reflectivityColor,\r\n            glossiness: babylonPBRMaterial._microSurface,\r\n        };\r\n\r\n        const albedoTexture = babylonPBRMaterial._albedoTexture;\r\n        const reflectivityTexture = babylonPBRMaterial._reflectivityTexture;\r\n        const useMicrosurfaceFromReflectivityMapAlpha = babylonPBRMaterial._useMicroSurfaceFromReflectivityMapAlpha;\r\n        if (reflectivityTexture && !useMicrosurfaceFromReflectivityMapAlpha) {\r\n            return await Promise.reject(\"_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported\");\r\n        }\r\n\r\n        if ((albedoTexture || reflectivityTexture) && hasUVs) {\r\n            this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n\r\n            const samplerIndex = this._exportTextureSampler(albedoTexture || reflectivityTexture);\r\n            const metallicRoughnessFactors = await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(albedoTexture, reflectivityTexture, specGloss, mimeType);\r\n\r\n            const textures = this._exporter._textures;\r\n\r\n            if (metallicRoughnessFactors.baseColorTextureData) {\r\n                const imageIndex = this._exportImage(`baseColor${textures.length}`, mimeType, metallicRoughnessFactors.baseColorTextureData);\r\n                pbrMetallicRoughness.baseColorTexture = this._exportTextureInfo(imageIndex, samplerIndex, albedoTexture?.coordinatesIndex);\r\n            }\r\n\r\n            if (metallicRoughnessFactors.metallicRoughnessTextureData) {\r\n                const imageIndex = this._exportImage(`metallicRoughness${textures.length}`, mimeType, metallicRoughnessFactors.metallicRoughnessTextureData);\r\n                pbrMetallicRoughness.metallicRoughnessTexture = this._exportTextureInfo(imageIndex, samplerIndex, reflectivityTexture?.coordinatesIndex);\r\n            }\r\n\r\n            return metallicRoughnessFactors;\r\n        } else {\r\n            return this._convertSpecularGlossinessToMetallicRoughness(specGloss);\r\n        }\r\n    }\r\n\r\n    public async exportPBRMaterialAsync(babylonPBRMaterial: PBRBaseMaterial, mimeType: ImageMimeType, hasUVs: boolean): Promise<number> {\r\n        const glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness = {};\r\n\r\n        const glTFMaterial: IMaterial = {\r\n            name: babylonPBRMaterial.name,\r\n        };\r\n\r\n        const useMetallicRoughness = babylonPBRMaterial.isMetallicWorkflow();\r\n\r\n        if (useMetallicRoughness) {\r\n            const albedoColor = babylonPBRMaterial._albedoColor;\r\n            const alpha = babylonPBRMaterial.alpha;\r\n            if (albedoColor) {\r\n                glTFPbrMetallicRoughness.baseColorFactor = [albedoColor.r, albedoColor.g, albedoColor.b, alpha];\r\n            }\r\n        }\r\n\r\n        const metallicRoughness = useMetallicRoughness\r\n            ? await this._convertMetalRoughFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasUVs)\r\n            : await this._convertSpecGlossFactorsToMetallicRoughnessAsync(babylonPBRMaterial, mimeType, glTFPbrMetallicRoughness, hasUVs);\r\n\r\n        await this._setMetallicRoughnessPbrMaterialAsync(metallicRoughness, babylonPBRMaterial, glTFMaterial, glTFPbrMetallicRoughness, mimeType, hasUVs);\r\n        await this._finishMaterialAsync(glTFMaterial, babylonPBRMaterial, mimeType);\r\n\r\n        const materials = this._exporter._materials;\r\n        materials.push(glTFMaterial);\r\n        return materials.length - 1;\r\n    }\r\n\r\n    private async _setMetallicRoughnessPbrMaterialAsync(\r\n        metallicRoughness: IPBRMetallicRoughness,\r\n        babylonPBRMaterial: PBRBaseMaterial,\r\n        glTFMaterial: IMaterial,\r\n        glTFPbrMetallicRoughness: IMaterialPbrMetallicRoughness,\r\n        mimeType: ImageMimeType,\r\n        hasUVs: boolean\r\n    ): Promise<void> {\r\n        SetAlphaMode(glTFMaterial, babylonPBRMaterial);\r\n\r\n        if (!metallicRoughness.baseColor.equalsWithEpsilon(White, Epsilon) || !Scalar.WithinEpsilon(babylonPBRMaterial.alpha, 1, Epsilon)) {\r\n            glTFPbrMetallicRoughness.baseColorFactor = [metallicRoughness.baseColor.r, metallicRoughness.baseColor.g, metallicRoughness.baseColor.b, babylonPBRMaterial.alpha];\r\n        }\r\n\r\n        if (metallicRoughness.metallic != null && metallicRoughness.metallic !== 1) {\r\n            glTFPbrMetallicRoughness.metallicFactor = metallicRoughness.metallic;\r\n        }\r\n        if (metallicRoughness.roughness != null && metallicRoughness.roughness !== 1) {\r\n            glTFPbrMetallicRoughness.roughnessFactor = metallicRoughness.roughness;\r\n        }\r\n\r\n        if (babylonPBRMaterial.backFaceCulling != null && !babylonPBRMaterial.backFaceCulling) {\r\n            if (!babylonPBRMaterial._twoSidedLighting) {\r\n                Tools.Warn(babylonPBRMaterial.name + \": Back-face culling disabled and two-sided lighting disabled is not supported in glTF.\");\r\n            }\r\n            glTFMaterial.doubleSided = true;\r\n        }\r\n\r\n        if (hasUVs) {\r\n            const promises: Promise<void>[] = [];\r\n\r\n            const bumpTexture = babylonPBRMaterial._bumpTexture;\r\n            if (bumpTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(bumpTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.normalTexture = glTFTexture;\r\n                            if (bumpTexture.level !== 1) {\r\n                                glTFMaterial.normalTexture.scale = bumpTexture.level;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const ambientTexture = babylonPBRMaterial._ambientTexture;\r\n            if (ambientTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(ambientTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            const occlusionTexture: IMaterialOcclusionTextureInfo = {\r\n                                index: glTFTexture.index,\r\n                                texCoord: glTFTexture.texCoord,\r\n                                extensions: glTFTexture.extensions,\r\n                            };\r\n\r\n                            glTFMaterial.occlusionTexture = occlusionTexture;\r\n                            const ambientTextureStrength = babylonPBRMaterial._ambientTextureStrength;\r\n                            if (ambientTextureStrength) {\r\n                                occlusionTexture.strength = ambientTextureStrength;\r\n                            }\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            const emissiveTexture = babylonPBRMaterial._emissiveTexture;\r\n            if (emissiveTexture) {\r\n                promises.push(\r\n                    this.exportTextureAsync(emissiveTexture, mimeType).then((glTFTexture) => {\r\n                        if (glTFTexture) {\r\n                            glTFMaterial.emissiveTexture = glTFTexture;\r\n                        }\r\n                    })\r\n                );\r\n            }\r\n\r\n            if (promises.length > 0) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonPBRMaterial);\r\n                await Promise.all(promises);\r\n            }\r\n        }\r\n\r\n        const emissiveColor = babylonPBRMaterial._emissiveColor;\r\n        if (!emissiveColor.equalsWithEpsilon(Black, Epsilon)) {\r\n            glTFMaterial.emissiveFactor = emissiveColor.asArray();\r\n        }\r\n\r\n        glTFMaterial.pbrMetallicRoughness = glTFPbrMetallicRoughness;\r\n    }\r\n\r\n    /**\r\n     * Get the RGBA pixel data from a texture\r\n     * @param babylonTexture\r\n     * @returns an array buffer promise containing the pixel data\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    private _getPixelsFromTextureAsync(babylonTexture: BaseTexture): Promise<Nullable<Uint8Array | Float32Array>> {\r\n        // If the internal texture format is compressed, we cannot read the pixels directly.\r\n        if (IsCompressedTextureFormat(babylonTexture.textureFormat)) {\r\n            return GetTextureDataAsync(babylonTexture, babylonTexture._texture!.width, babylonTexture._texture!.height);\r\n        }\r\n\r\n        return babylonTexture.textureType === Constants.TEXTURETYPE_UNSIGNED_BYTE\r\n            ? (babylonTexture.readPixels() as Promise<Uint8Array>)\r\n            : (babylonTexture.readPixels() as Promise<Float32Array>);\r\n    }\r\n\r\n    public async exportTextureAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        const extensionPromise = this._exporter._extensionsPreExportTextureAsync(\"exporter\", babylonTexture as Texture, mimeType);\r\n        if (!extensionPromise) {\r\n            return await this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n        }\r\n\r\n        return await extensionPromise.then(async (texture) => {\r\n            if (!texture) {\r\n                return await this._exportTextureInfoAsync(babylonTexture, mimeType);\r\n            }\r\n            return await this._exportTextureInfoAsync(texture, mimeType);\r\n        });\r\n    }\r\n\r\n    private async _exportTextureInfoAsync(babylonTexture: BaseTexture, mimeType: ImageMimeType): Promise<Nullable<ITextureInfo>> {\r\n        let textureInfo = this._textureMap.get(babylonTexture);\r\n        if (!textureInfo) {\r\n            const pixels = await this._getPixelsFromTextureAsync(babylonTexture);\r\n            if (!pixels) {\r\n                return null;\r\n            }\r\n\r\n            const samplerIndex = this._exportTextureSampler(babylonTexture);\r\n\r\n            // Preserve texture mime type if defined\r\n            const textureMimeType = (babylonTexture as Texture).mimeType;\r\n            if (textureMimeType) {\r\n                switch (textureMimeType) {\r\n                    case \"image/jpeg\":\r\n                    case \"image/png\":\r\n                    case \"image/webp\":\r\n                        mimeType = textureMimeType as ImageMimeType;\r\n                        break;\r\n                    default:\r\n                        Tools.Warn(`Unsupported media type: ${textureMimeType}. Exporting texture as PNG.`);\r\n                        // Will later fallback to default mime type, image/png, from Canvas API\r\n                        break;\r\n                }\r\n            }\r\n\r\n            const internalTextureToImage = this._internalTextureToImage;\r\n            const internalTextureUniqueId = babylonTexture.getInternalTexture()!.uniqueId;\r\n            internalTextureToImage[internalTextureUniqueId] ||= {};\r\n            let imageIndexPromise = internalTextureToImage[internalTextureUniqueId][mimeType];\r\n            if (imageIndexPromise === undefined) {\r\n                const size = babylonTexture.getSize();\r\n                imageIndexPromise = (async () => {\r\n                    const data = await this._getImageDataAsync(pixels, size.width, size.height, mimeType);\r\n                    return this._exportImage(babylonTexture.name, mimeType, data);\r\n                })();\r\n                internalTextureToImage[internalTextureUniqueId][mimeType] = imageIndexPromise;\r\n            }\r\n\r\n            textureInfo = this._exportTextureInfo(await imageIndexPromise, samplerIndex, babylonTexture.coordinatesIndex);\r\n            this._textureMap.set(babylonTexture, textureInfo);\r\n            this._exporter._extensionsPostExportTextures(\"exporter\", textureInfo, babylonTexture);\r\n        }\r\n\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportImage(name: string, mimeType: ImageMimeType, data: ArrayBuffer): number {\r\n        const images = this._exporter._images;\r\n\r\n        let image: IImage;\r\n        if (this._exporter._shouldUseGlb) {\r\n            image = {\r\n                name: name,\r\n                mimeType: mimeType,\r\n                bufferView: undefined, // Will be updated later by BufferManager\r\n            };\r\n            const bufferView = this._exporter._bufferManager.createBufferView(new Uint8Array(data));\r\n            this._exporter._bufferManager.setBufferView(image, bufferView);\r\n        } else {\r\n            // Build a unique URI\r\n            const baseName = name.replace(/\\.\\/|\\/|\\.\\\\|\\\\/g, \"_\");\r\n            const extension = GetFileExtensionFromMimeType(mimeType);\r\n            let fileName = baseName + extension;\r\n            if (images.some((image) => image.uri === fileName)) {\r\n                fileName = `${baseName}_${Tools.RandomId()}${extension}`;\r\n            }\r\n\r\n            image = {\r\n                name: name,\r\n                uri: fileName,\r\n            };\r\n            this._exporter._imageData[fileName] = { data: data, mimeType: mimeType }; // Save image data to be written to file later\r\n        }\r\n\r\n        images.push(image);\r\n\r\n        return images.length - 1;\r\n    }\r\n\r\n    private _exportTextureInfo(imageIndex: number, samplerIndex: number, coordinatesIndex?: number): ITextureInfo {\r\n        const textures = this._exporter._textures;\r\n        let textureIndex = textures.findIndex((t) => t.sampler == samplerIndex && t.source === imageIndex);\r\n        if (textureIndex === -1) {\r\n            textureIndex = textures.length;\r\n            textures.push({\r\n                source: imageIndex,\r\n                sampler: samplerIndex,\r\n            });\r\n        }\r\n\r\n        const textureInfo: ITextureInfo = { index: textureIndex };\r\n        if (coordinatesIndex) {\r\n            textureInfo.texCoord = coordinatesIndex;\r\n        }\r\n        return textureInfo;\r\n    }\r\n\r\n    private _exportTextureSampler(texture: Nullable<BaseTexture>): number {\r\n        const sampler = this._getTextureSampler(texture);\r\n\r\n        // if a pre-existing sampler with identical parameters exists, then reuse the previous sampler\r\n        const samplers = this._exporter._samplers;\r\n        const samplerIndex = samplers.findIndex(\r\n            (s) => s.minFilter === sampler.minFilter && s.magFilter === sampler.magFilter && s.wrapS === sampler.wrapS && s.wrapT === sampler.wrapT\r\n        );\r\n        if (samplerIndex !== -1) {\r\n            return samplerIndex;\r\n        }\r\n\r\n        samplers.push(sampler);\r\n        return samplers.length - 1;\r\n    }\r\n}\r\n","/* eslint-disable jsdoc/require-jsdoc */\r\nimport type { INode } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, DataArray, IndicesArray } from \"core/types\";\r\nimport type { Vector4 } from \"core/Maths/math.vector\";\r\nimport { Quaternion, TmpVectors, Matrix, Vector3 } from \"core/Maths/math.vector\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { EnumerateFloatValues } from \"core/Buffers/bufferUtils\";\r\nimport type { Node } from \"core/node\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport type { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\n\r\n// Matrix that converts handedness on the X-axis. Can convert from LH to RH and vice versa.\r\nconst ConvertHandednessMatrix = Matrix.Compose(new Vector3(-1, 1, 1), Quaternion.Identity(), Vector3.Zero());\r\n\r\n// Default values for comparison.\r\nexport const DefaultTranslation = Vector3.Zero();\r\nexport const DefaultRotation = Quaternion.Identity();\r\nexport const DefaultScale = Vector3.One();\r\nconst DefaultLoaderCameraParentScaleLh = new Vector3(-1, 1, 1);\r\n\r\n/**\r\n * Get the information necessary for enumerating a vertex buffer.\r\n * @param vertexBuffer the vertex buffer to enumerate\r\n * @param meshes the meshes that use the vertex buffer\r\n * @returns the information necessary to enumerate the vertex buffer\r\n */\r\nexport function GetVertexBufferInfo(vertexBuffer: VertexBuffer, meshes: AbstractMesh[]) {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const componentCount = vertexBuffer.getSize();\r\n    const totalVertices = meshes.reduce((max, current) => {\r\n        return current.getTotalVertices() > max ? current.getTotalVertices() : max;\r\n    }, -Number.MAX_VALUE); // Get the max total vertices count, to ensure we capture the full range of vertex data used by the meshes.\r\n    const count = totalVertices * componentCount;\r\n    const kind = vertexBuffer.getKind();\r\n\r\n    return { byteOffset, byteStride, componentCount, type, count, normalized, totalVertices, kind };\r\n}\r\n\r\nexport function GetAccessorElementCount(accessorType: AccessorType): number {\r\n    switch (accessorType) {\r\n        case AccessorType.MAT2:\r\n            return 4;\r\n        case AccessorType.MAT3:\r\n            return 9;\r\n        case AccessorType.MAT4:\r\n            return 16;\r\n        case AccessorType.SCALAR:\r\n            return 1;\r\n        case AccessorType.VEC2:\r\n            return 2;\r\n        case AccessorType.VEC3:\r\n            return 3;\r\n        case AccessorType.VEC4:\r\n            return 4;\r\n    }\r\n}\r\n\r\nexport function FloatsNeed16BitInteger(floatArray: FloatArray): boolean {\r\n    return floatArray.some((value) => value >= 256);\r\n}\r\n\r\nexport function IsStandardVertexAttribute(type: string): boolean {\r\n    switch (type) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.ColorKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\n\r\nexport function GetAccessorType(kind: string, hasVertexColorAlpha: boolean): AccessorType {\r\n    if (kind == VertexBuffer.ColorKind) {\r\n        return hasVertexColorAlpha ? AccessorType.VEC4 : AccessorType.VEC3;\r\n    }\r\n\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n        case VertexBuffer.NormalKind:\r\n            return AccessorType.VEC3;\r\n        case VertexBuffer.TangentKind:\r\n        case VertexBuffer.MatricesIndicesKind:\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n        case VertexBuffer.MatricesWeightsKind:\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return AccessorType.VEC4;\r\n        case VertexBuffer.UVKind:\r\n        case VertexBuffer.UV2Kind:\r\n        case VertexBuffer.UV3Kind:\r\n        case VertexBuffer.UV4Kind:\r\n        case VertexBuffer.UV5Kind:\r\n        case VertexBuffer.UV6Kind:\r\n            return AccessorType.VEC2;\r\n    }\r\n\r\n    throw new Error(`Unknown kind ${kind}`);\r\n}\r\n\r\nexport function GetAttributeType(kind: string): string {\r\n    switch (kind) {\r\n        case VertexBuffer.PositionKind:\r\n            return \"POSITION\";\r\n        case VertexBuffer.NormalKind:\r\n            return \"NORMAL\";\r\n        case VertexBuffer.TangentKind:\r\n            return \"TANGENT\";\r\n        case VertexBuffer.ColorKind:\r\n            return \"COLOR_0\";\r\n        case VertexBuffer.UVKind:\r\n            return \"TEXCOORD_0\";\r\n        case VertexBuffer.UV2Kind:\r\n            return \"TEXCOORD_1\";\r\n        case VertexBuffer.UV3Kind:\r\n            return \"TEXCOORD_2\";\r\n        case VertexBuffer.UV4Kind:\r\n            return \"TEXCOORD_3\";\r\n        case VertexBuffer.UV5Kind:\r\n            return \"TEXCOORD_4\";\r\n        case VertexBuffer.UV6Kind:\r\n            return \"TEXCOORD_5\";\r\n        case VertexBuffer.MatricesIndicesKind:\r\n            return \"JOINTS_0\";\r\n        case VertexBuffer.MatricesIndicesExtraKind:\r\n            return \"JOINTS_1\";\r\n        case VertexBuffer.MatricesWeightsKind:\r\n            return \"WEIGHTS_0\";\r\n        case VertexBuffer.MatricesWeightsExtraKind:\r\n            return \"WEIGHTS_1\";\r\n    }\r\n\r\n    throw new Error(`Unknown kind: ${kind}`);\r\n}\r\n\r\nexport function GetPrimitiveMode(fillMode: number): MeshPrimitiveMode {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n            return MeshPrimitiveMode.TRIANGLES;\r\n        case Material.TriangleStripDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_STRIP;\r\n        case Material.TriangleFanDrawMode:\r\n            return MeshPrimitiveMode.TRIANGLE_FAN;\r\n        case Material.PointListDrawMode:\r\n        case Material.PointFillMode:\r\n            return MeshPrimitiveMode.POINTS;\r\n        case Material.LineLoopDrawMode:\r\n            return MeshPrimitiveMode.LINE_LOOP;\r\n        case Material.LineListDrawMode:\r\n            return MeshPrimitiveMode.LINES;\r\n        case Material.LineStripDrawMode:\r\n            return MeshPrimitiveMode.LINE_STRIP;\r\n    }\r\n\r\n    throw new Error(`Unknown fill mode: ${fillMode}`);\r\n}\r\n\r\nexport function IsTriangleFillMode(fillMode: number): boolean {\r\n    switch (fillMode) {\r\n        case Material.TriangleFillMode:\r\n        case Material.TriangleStripDrawMode:\r\n        case Material.TriangleFanDrawMode:\r\n            return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nexport function NormalizeTangent(tangent: Vector4 | Vector3) {\r\n    const length = Math.sqrt(tangent.x * tangent.x + tangent.y * tangent.y + tangent.z * tangent.z);\r\n    if (length > 0) {\r\n        tangent.x /= length;\r\n        tangent.y /= length;\r\n        tangent.z /= length;\r\n    }\r\n}\r\n\r\nexport function ConvertToRightHandedPosition(value: Vector3): Vector3 {\r\n    value.x *= -1;\r\n    return value;\r\n}\r\n\r\n/**\r\n * Converts, in-place, a left-handed quaternion to a right-handed quaternion via a change of basis.\r\n * @param value the unit quaternion to convert\r\n * @returns the converted quaternion\r\n */\r\nexport function ConvertToRightHandedRotation(value: Quaternion): Quaternion {\r\n    /**\r\n     * This is the simplified version of the following equation:\r\n     *    q' = to_quaternion(M * to_matrix(q) * M^-1)\r\n     * where M is the conversion matrix `convertHandednessMatrix`,\r\n     * q is the input quaternion, and q' is the converted quaternion.\r\n     * Reference: https://d3cw3dd2w32x2b.cloudfront.net/wp-content/uploads/2015/01/matrix-to-quat.pdf\r\n     */\r\n    if (value.x * value.x + value.y * value.y > 0.5) {\r\n        const absX = Math.abs(value.x);\r\n        const absY = Math.abs(value.y);\r\n        if (absX > absY) {\r\n            const sign = Math.sign(value.x);\r\n            value.x = absX;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w *= sign;\r\n        } else {\r\n            const sign = Math.sign(value.y);\r\n            value.x *= -sign;\r\n            value.y = absY;\r\n            value.z *= sign;\r\n            value.w *= -sign;\r\n        }\r\n    } else {\r\n        const absZ = Math.abs(value.z);\r\n        const absW = Math.abs(value.w);\r\n        if (absZ > absW) {\r\n            const sign = Math.sign(value.z);\r\n            value.x *= -sign;\r\n            value.y *= sign;\r\n            value.z = absZ;\r\n            value.w *= -sign;\r\n        } else {\r\n            const sign = Math.sign(value.w);\r\n            value.x *= sign;\r\n            value.y *= -sign;\r\n            value.z *= -sign;\r\n            value.w = absW;\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\n/**\r\n * Pre-multiplies a 180-degree Y rotation to the quaternion, in order to match glTF's flipped forward direction for cameras.\r\n * @param rotation Target camera rotation.\r\n */\r\nexport function Rotate180Y(rotation: Quaternion): void {\r\n    // Simplified from: rotation * (0, 1, 0, 0).\r\n    rotation.copyFromFloats(-rotation.z, rotation.w, rotation.x, -rotation.y);\r\n}\r\n\r\n/**\r\n * Collapses GLTF parent and node into a single node, ignoring scaling.\r\n * This is useful for removing nodes that were added by the GLTF importer.\r\n * @param node Original GLTF node (Light or Camera).\r\n * @param parentNode Target parent node.\r\n */\r\nexport function CollapseChildIntoParent(node: INode, parentNode: INode): void {\r\n    const parentTranslation = Vector3.FromArrayToRef(parentNode.translation || [0, 0, 0], 0, TmpVectors.Vector3[0]);\r\n    const parentRotation = Quaternion.FromArrayToRef(parentNode.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[0]);\r\n    const parentMatrix = Matrix.ComposeToRef(DefaultScale, parentRotation, parentTranslation, TmpVectors.Matrix[0]);\r\n\r\n    const translation = Vector3.FromArrayToRef(node.translation || [0, 0, 0], 0, TmpVectors.Vector3[2]);\r\n    const rotation = Quaternion.FromArrayToRef(node.rotation || [0, 0, 0, 1], 0, TmpVectors.Quaternion[1]);\r\n    const matrix = Matrix.ComposeToRef(DefaultScale, rotation, translation, TmpVectors.Matrix[1]);\r\n\r\n    parentMatrix.multiplyToRef(matrix, matrix);\r\n    matrix.decompose(undefined, parentRotation, parentTranslation);\r\n\r\n    if (parentTranslation.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n        delete parentNode.translation;\r\n    } else {\r\n        parentNode.translation = parentTranslation.asArray();\r\n    }\r\n\r\n    if (parentRotation.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n        delete parentNode.rotation;\r\n    } else {\r\n        parentNode.rotation = parentRotation.asArray();\r\n    }\r\n\r\n    if (parentNode.scale) {\r\n        delete parentNode.scale;\r\n    }\r\n}\r\n\r\n/**\r\n * Checks whether a camera or light node is candidate for collapsing with its parent node.\r\n * This is useful for roundtrips, as the glTF Importer parents a new node to\r\n * lights and cameras to store their original transformation information.\r\n * @param babylonNode Babylon light or camera node.\r\n * @param parentBabylonNode Target Babylon parent node.\r\n * @returns True if the two nodes can be merged, false otherwise.\r\n */\r\nexport function IsChildCollapsible(babylonNode: ShadowLight | TargetCamera, parentBabylonNode: Node): boolean {\r\n    if (!(parentBabylonNode instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Verify child is the only descendant\r\n    const isOnlyDescendant = parentBabylonNode.getChildren().length === 1 && babylonNode.getChildren().length === 0 && babylonNode.parent === parentBabylonNode;\r\n    if (!isOnlyDescendant) {\r\n        return false;\r\n    }\r\n\r\n    // Verify parent has the expected scaling, determined by the node type and scene's coordinate system.\r\n    const scene = babylonNode.getScene();\r\n    const expectedScale = babylonNode instanceof TargetCamera && !scene.useRightHandedSystem ? DefaultLoaderCameraParentScaleLh : DefaultScale;\r\n\r\n    if (!parentBabylonNode.scaling.equalsWithEpsilon(expectedScale, Epsilon)) {\r\n        Logger.Warn(`Cannot collapse node ${babylonNode.name} into parent node ${parentBabylonNode.name} with modified scaling.`);\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\nexport function IsNoopNode(node: Node, useRightHandedSystem: boolean): boolean {\r\n    if (!(node instanceof TransformNode)) {\r\n        return false;\r\n    }\r\n\r\n    // Transform\r\n    if (useRightHandedSystem) {\r\n        const matrix = node.getWorldMatrix();\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    } else {\r\n        const matrix = node.getWorldMatrix().multiplyToRef(ConvertHandednessMatrix, TmpVectors.Matrix[0]);\r\n        if (!matrix.equalsWithEpsilon(Matrix.IdentityReadOnly, Epsilon)) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // Geometry\r\n    if (node instanceof AbstractMesh && node.geometry) {\r\n        return false;\r\n    }\r\n\r\n    return true;\r\n}\r\n\r\n/**\r\n * Converts an IndicesArray into either Uint32Array or Uint16Array, only copying if the data is number[].\r\n * @param indices input array to be converted\r\n * @param start starting index to copy from\r\n * @param count number of indices to copy\r\n * @returns a Uint32Array or Uint16Array\r\n * @internal\r\n */\r\nexport function IndicesArrayToTypedArray(indices: IndicesArray, start: number, count: number, is32Bits: boolean): Uint32Array | Uint16Array {\r\n    if (indices instanceof Uint16Array || indices instanceof Uint32Array) {\r\n        return indices;\r\n    }\r\n\r\n    // If Int32Array, cast the indices (which are all positive) to Uint32Array\r\n    if (indices instanceof Int32Array) {\r\n        return new Uint32Array(indices.buffer, indices.byteOffset, indices.length);\r\n    }\r\n\r\n    const subarray = indices.slice(start, start + count);\r\n    return is32Bits ? new Uint32Array(subarray) : new Uint16Array(subarray);\r\n}\r\n\r\nexport function DataArrayToUint8Array(data: DataArray): Uint8Array {\r\n    if (data instanceof Array) {\r\n        const floatData = new Float32Array(data);\r\n        return new Uint8Array(floatData.buffer, floatData.byteOffset, floatData.byteLength);\r\n    }\r\n\r\n    return ArrayBuffer.isView(data) ? new Uint8Array(data.buffer, data.byteOffset, data.byteLength) : new Uint8Array(data);\r\n}\r\n\r\nexport function GetMinMax(data: DataArray, vertexBuffer: VertexBuffer, start: number, count: number): { min: number[]; max: number[] } {\r\n    const { byteOffset, byteStride, type, normalized } = vertexBuffer;\r\n    const size = vertexBuffer.getSize();\r\n    const min = new Array<number>(size).fill(Infinity);\r\n    const max = new Array<number>(size).fill(-Infinity);\r\n    EnumerateFloatValues(data, byteOffset + start * byteStride, byteStride, size, type, count * size, normalized, (values) => {\r\n        for (let i = 0; i < size; i++) {\r\n            min[i] = Math.min(min[i], values[i]);\r\n            max[i] = Math.max(max[i], values[i]);\r\n        }\r\n    });\r\n\r\n    return { min, max };\r\n}\r\n\r\n/**\r\n * Removes, in-place, object properties which have the same value as the default value.\r\n * Useful for avoiding unnecessary properties in the glTF JSON.\r\n * @param object the object to omit default values from\r\n * @param defaultValues a partial object with default values\r\n * @returns object with default values omitted\r\n */\r\nexport function OmitDefaultValues<T extends object>(object: T, defaultValues: Partial<T>): T {\r\n    for (const [key, value] of Object.entries(object)) {\r\n        const defaultValue = defaultValues[key as keyof T];\r\n        if ((Array.isArray(value) && Array.isArray(defaultValue) && AreArraysEqual(value, defaultValue)) || value === defaultValue) {\r\n            delete object[key as keyof T];\r\n        }\r\n    }\r\n    return object;\r\n}\r\n\r\nfunction AreArraysEqual(array1: unknown[], array2: unknown[]): boolean {\r\n    return array1.length === array2.length && array1.every((val, i) => val === array2[i]);\r\n}\r\n","/* eslint-disable @typescript-eslint/naming-convention */\r\n/* eslint-disable babylonjs/available */\r\nimport type { TypedArray } from \"core/types\";\r\n\r\nconst TypedArrayToWriteMethod = new Map<Function, (dataView: DataView, byteOffset: number, value: number) => void>([\r\n    [Int8Array, (d, b, v) => d.setInt8(b, v)],\r\n    [Uint8Array, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Uint8ClampedArray, (dv, bo, v) => dv.setUint8(bo, v)],\r\n    [Int16Array, (dv, bo, v) => dv.setInt16(bo, v, true)],\r\n    [Uint16Array, (dv, bo, v) => dv.setUint16(bo, v, true)],\r\n    [Int32Array, (dv, bo, v) => dv.setInt32(bo, v, true)],\r\n    [Uint32Array, (dv, bo, v) => dv.setUint32(bo, v, true)],\r\n    [Float32Array, (dv, bo, v) => dv.setFloat32(bo, v, true)],\r\n    [Float64Array, (dv, bo, v) => dv.setFloat64(bo, v, true)],\r\n]);\r\n\r\n/** @internal */\r\nexport class DataWriter {\r\n    private _data: Uint8Array;\r\n    private _dataView: DataView;\r\n    private _byteOffset: number;\r\n\r\n    public writeTypedArray(value: Exclude<TypedArray, BigInt64Array | BigUint64Array>): void {\r\n        this._checkGrowBuffer(value.byteLength);\r\n        const setMethod = TypedArrayToWriteMethod.get(value.constructor)!;\r\n        for (let i = 0; i < value.length; i++) {\r\n            setMethod(this._dataView, this._byteOffset, value[i]);\r\n            this._byteOffset += value.BYTES_PER_ELEMENT;\r\n        }\r\n    }\r\n\r\n    public constructor(byteLength: number) {\r\n        this._data = new Uint8Array(byteLength);\r\n        this._dataView = new DataView(this._data.buffer);\r\n        this._byteOffset = 0;\r\n    }\r\n\r\n    public get byteOffset(): number {\r\n        return this._byteOffset;\r\n    }\r\n\r\n    public getOutputData(): Uint8Array {\r\n        return new Uint8Array(this._data.buffer, 0, this._byteOffset);\r\n    }\r\n\r\n    public writeUInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setUint8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt8(value: number): void {\r\n        this._checkGrowBuffer(1);\r\n        this._dataView.setInt8(this._byteOffset, value);\r\n        this._byteOffset++;\r\n    }\r\n\r\n    public writeInt16(entry: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setInt16(this._byteOffset, entry, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeUInt16(value: number): void {\r\n        this._checkGrowBuffer(2);\r\n        this._dataView.setUint16(this._byteOffset, value, true);\r\n        this._byteOffset += 2;\r\n    }\r\n\r\n    public writeInt32(entry: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setInt32(this._byteOffset, entry, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeUInt32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setUint32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat32(value: number): void {\r\n        this._checkGrowBuffer(4);\r\n        this._dataView.setFloat32(this._byteOffset, value, true);\r\n        this._byteOffset += 4;\r\n    }\r\n\r\n    public writeFloat64(value: number): void {\r\n        this._checkGrowBuffer(8);\r\n        this._dataView.setFloat64(this._byteOffset, value, true);\r\n        this._byteOffset += 8;\r\n    }\r\n\r\n    private _checkGrowBuffer(byteLength: number): void {\r\n        const newByteLength = this.byteOffset + byteLength;\r\n        if (newByteLength > this._data.byteLength) {\r\n            const newData = new Uint8Array(newByteLength * 2);\r\n            newData.set(this._data);\r\n            this._data = newData;\r\n            this._dataView = new DataView(this._data.buffer);\r\n        }\r\n    }\r\n}\r\n","import type { TypedArray } from \"core/types\";\nimport type { AccessorComponentType, AccessorType, IAccessor, IBufferView } from \"babylonjs-gltf2interface\";\nimport { DataWriter } from \"./dataWriter\";\n\ntype TypedArrayForglTF = Exclude<TypedArray, Float64Array | BigInt64Array | BigUint64Array>;\n\ninterface IPropertyWithBufferView {\n    bufferView?: number;\n}\n\nfunction GetHighestByteAlignment(byteLength: number): number {\n    if (byteLength % 4 === 0) {\n        return 4;\n    }\n    if (byteLength % 2 === 0) {\n        return 2;\n    }\n    return 1;\n}\n\n/**\n * Utility class to centralize the management of binary data, bufferViews, and the objects that reference them.\n * @internal\n */\nexport class BufferManager {\n    /**\n     * Maps a bufferView to its data\n     */\n    private _bufferViewToData: Map<IBufferView, TypedArrayForglTF> = new Map<IBufferView, TypedArrayForglTF>();\n\n    /**\n     * Maps a bufferView to glTF objects that reference it via a \"bufferView\" property (e.g. accessors, images)\n     */\n    private _bufferViewToProperties: Map<IBufferView, IPropertyWithBufferView[]> = new Map<IBufferView, IPropertyWithBufferView[]>();\n\n    /**\n     * Maps an accessor to its bufferView\n     */\n    private _accessorToBufferView: Map<IAccessor, IBufferView> = new Map<IAccessor, IBufferView>();\n\n    /**\n     * Generates a binary buffer from the stored bufferViews. Also populates the bufferViews list.\n     * @param bufferViews The list of bufferViews to be populated while writing the binary\n     * @returns The binary buffer\n     */\n    public generateBinary(bufferViews: IBufferView[]): Uint8Array {\n        // Construct a DataWriter with the total byte length to prevent resizing\n        let totalByteLength = 0;\n        this._bufferViewToData.forEach((data) => {\n            totalByteLength += data.byteLength;\n        });\n        const dataWriter = new DataWriter(totalByteLength);\n\n        // Order the bufferViews in descending order of their alignment requirements\n        const orderedBufferViews = Array.from(this._bufferViewToData.keys()).sort((a, b) => GetHighestByteAlignment(b.byteLength) - GetHighestByteAlignment(a.byteLength));\n\n        // Fill in the bufferViews list and missing bufferView index references while writing the binary\n        for (const bufferView of orderedBufferViews) {\n            bufferView.byteOffset = dataWriter.byteOffset;\n            bufferViews.push(bufferView);\n\n            const bufferViewIndex = bufferViews.length - 1;\n            const properties = this.getPropertiesWithBufferView(bufferView);\n            for (const object of properties) {\n                object.bufferView = bufferViewIndex;\n            }\n\n            dataWriter.writeTypedArray(this._bufferViewToData.get(bufferView)!);\n\n            this._bufferViewToData.delete(bufferView); // Try to free up memory ASAP\n        }\n\n        return dataWriter.getOutputData();\n    }\n\n    /**\n     * Creates a buffer view based on the supplied arguments\n     * @param data a TypedArray to create the bufferView for\n     * @param byteStride byte distance between consecutive elements\n     * @returns bufferView for glTF\n     */\n    public createBufferView(data: TypedArrayForglTF, byteStride?: number): IBufferView {\n        const bufferView: IBufferView = {\n            buffer: 0,\n            byteOffset: undefined, // byteOffset will be set later, when we write the binary and decide bufferView ordering\n            byteLength: data.byteLength,\n            byteStride: byteStride,\n        };\n        this._bufferViewToData.set(bufferView, data);\n        return bufferView;\n    }\n\n    /**\n     * Creates an accessor based on the supplied arguments and assigns it to the bufferView\n     * @param bufferView The glTF bufferView referenced by this accessor\n     * @param type The type of the accessor\n     * @param componentType The datatype of components in the attribute\n     * @param count The number of attributes referenced by this accessor\n     * @param byteOffset The offset relative to the start of the bufferView in bytes\n     * @param minMax Minimum and maximum value of each component in this attribute\n     * @param normalized Specifies whether integer data values are normalized before usage\n     * @returns accessor for glTF\n     */\n    public createAccessor(\n        bufferView: IBufferView,\n        type: AccessorType,\n        componentType: AccessorComponentType,\n        count: number,\n        byteOffset?: number,\n        minMax?: { min: number[]; max: number[] },\n        normalized?: boolean\n    ): IAccessor {\n        this._verifyBufferView(bufferView);\n        const accessor: IAccessor = {\n            bufferView: undefined, // bufferView will be set to a real index later, once we write the binary and decide bufferView ordering\n            componentType: componentType,\n            count: count,\n            type: type,\n            min: minMax?.min,\n            max: minMax?.max,\n            normalized: normalized,\n            byteOffset: byteOffset,\n        };\n        this.setBufferView(accessor, bufferView);\n        this._accessorToBufferView.set(accessor, bufferView);\n        return accessor;\n    }\n\n    /**\n     * Assigns a bufferView to a glTF object that references it\n     * @param object The glTF object\n     * @param bufferView The bufferView to assign\n     */\n    public setBufferView(object: IPropertyWithBufferView, bufferView: IBufferView) {\n        this._verifyBufferView(bufferView);\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        properties.push(object);\n    }\n\n    /**\n     * Removes buffer view from the binary data, as well as from all its known references\n     * @param bufferView the bufferView to remove\n     */\n    public removeBufferView(bufferView: IBufferView): void {\n        const properties = this.getPropertiesWithBufferView(bufferView);\n        for (const object of properties) {\n            if (object.bufferView !== undefined) {\n                delete object.bufferView;\n            }\n        }\n\n        this._bufferViewToData.delete(bufferView);\n        this._bufferViewToProperties.delete(bufferView);\n        this._accessorToBufferView.forEach((bv, accessor) => {\n            if (bv === bufferView) {\n                // Additionally, remove byteOffset from accessor referencing this bufferView\n                if (accessor.byteOffset !== undefined) {\n                    delete accessor.byteOffset;\n                }\n                this._accessorToBufferView.delete(accessor);\n            }\n        });\n    }\n\n    public getBufferView(accessor: IAccessor): IBufferView {\n        const bufferView = this._accessorToBufferView.get(accessor);\n        this._verifyBufferView(bufferView);\n        return bufferView!;\n    }\n\n    public getPropertiesWithBufferView(bufferView: IBufferView): IPropertyWithBufferView[] {\n        this._verifyBufferView(bufferView);\n        this._bufferViewToProperties.set(bufferView, this._bufferViewToProperties.get(bufferView) ?? []);\n        return this._bufferViewToProperties.get(bufferView)!;\n    }\n\n    public getData(bufferView: IBufferView): TypedArrayForglTF {\n        this._verifyBufferView(bufferView);\n        return this._bufferViewToData.get(bufferView)!;\n    }\n\n    private _verifyBufferView(bufferView?: IBufferView): void {\n        if (bufferView === undefined || !this._bufferViewToData.has(bufferView)) {\n            throw new Error(`BufferView ${bufferView} not found in BufferManager.`);\n        }\n    }\n}\n","import type { IAnimation, INode, IBufferView, IAccessor, IAnimationSampler, IAnimationChannel } from \"babylonjs-gltf2interface\";\r\nimport { AnimationSamplerInterpolation, AnimationChannelTargetPath, AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { Node } from \"core/node\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport { Animation } from \"core/Animations/animation\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\n\r\nimport type { IAnimationKey } from \"core/Animations/animationKey\";\r\nimport { AnimationKeyInterpolation } from \"core/Animations/animationKey\";\r\n\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\nimport { GetAccessorElementCount, ConvertToRightHandedPosition, Rotate180Y, ConvertToRightHandedRotation } from \"./glTFUtilities\";\r\n\r\n/**\r\n * @internal\r\n * Interface to store animation data.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationData {\r\n    /**\r\n     * Keyframe data.\r\n     */\r\n    inputs: number[];\r\n    /**\r\n     * Value data.\r\n     */\r\n    outputs: number[][];\r\n    /**\r\n     * Animation interpolation data.\r\n     */\r\n    samplerInterpolation: AnimationSamplerInterpolation;\r\n    /**\r\n     * Minimum keyframe value.\r\n     */\r\n    inputsMin: number;\r\n    /**\r\n     * Maximum keyframe value.\r\n     */\r\n    inputsMax: number;\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport interface _IAnimationInfo {\r\n    /**\r\n     * The target channel for the animation\r\n     */\r\n    animationChannelTargetPath: AnimationChannelTargetPath;\r\n    /**\r\n     * The glTF accessor type for the data.\r\n     */\r\n    dataAccessorType: AccessorType.VEC3 | AccessorType.VEC4 | AccessorType.SCALAR;\r\n    /**\r\n     * Specifies if quaternions should be used.\r\n     */\r\n    useQuaternion: boolean;\r\n}\r\n\r\n/**\r\n * @internal\r\n * Enum for handling in tangent and out tangent.\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nenum _TangentType {\r\n    /**\r\n     * Specifies that input tangents are used.\r\n     */\r\n    INTANGENT,\r\n    /**\r\n     * Specifies that output tangents are used.\r\n     */\r\n    OUTTANGENT,\r\n}\r\n\r\n/**\r\n * @internal\r\n * Utility class for generating glTF animation data from BabylonJS.\r\n */\r\nexport class _GLTFAnimation {\r\n    /**\r\n     * Determine if a node is transformable - ie has properties it should be part of animation of transformation.\r\n     * @param babylonNode the node to test\r\n     * @returns true if can be animated, false otherwise. False if the parameter is null or undefined.\r\n     */\r\n    private static _IsTransformable(babylonNode: Node): boolean {\r\n        return babylonNode && (babylonNode instanceof TransformNode || babylonNode instanceof Camera || babylonNode instanceof Light);\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     *\r\n     * Creates glTF channel animation from BabylonJS animation.\r\n     * @param babylonTransformNode - BabylonJS mesh.\r\n     * @param animation - animation.\r\n     * @param animationChannelTargetPath - The target animation channel.\r\n     * @param useQuaternion - Specifies if quaternions are used.\r\n     * @returns nullable IAnimationData\r\n     */\r\n    public static _CreateNodeAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number\r\n    ): Nullable<_IAnimationData> {\r\n        if (this._IsTransformable(babylonTransformNode)) {\r\n            const inputs: number[] = [];\r\n            const outputs: number[][] = [];\r\n            const keyFrames = animation.getKeys();\r\n            const minMaxKeyFrames = _GLTFAnimation._CalculateMinMaxKeyFrames(keyFrames);\r\n            const interpolationOrBake = _GLTFAnimation._DeduceInterpolation(keyFrames, animationChannelTargetPath, useQuaternion);\r\n\r\n            const interpolation = interpolationOrBake.interpolationType;\r\n            const shouldBakeAnimation = interpolationOrBake.shouldBakeAnimation;\r\n\r\n            if (shouldBakeAnimation) {\r\n                _GLTFAnimation._CreateBakedAnimation(\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    minMaxKeyFrames.min,\r\n                    minMaxKeyFrames.max,\r\n                    animation.framePerSecond,\r\n                    animationSampleRate,\r\n                    inputs,\r\n                    outputs,\r\n                    minMaxKeyFrames,\r\n                    useQuaternion\r\n                );\r\n            } else {\r\n                if (interpolation === AnimationSamplerInterpolation.LINEAR || interpolation === AnimationSamplerInterpolation.STEP) {\r\n                    _GLTFAnimation._CreateLinearOrStepAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                    _GLTFAnimation._CreateCubicSplineAnimation(babylonTransformNode, animation, animationChannelTargetPath, inputs, outputs, useQuaternion);\r\n                } else {\r\n                    _GLTFAnimation._CreateBakedAnimation(\r\n                        babylonTransformNode,\r\n                        animation,\r\n                        animationChannelTargetPath,\r\n                        minMaxKeyFrames.min,\r\n                        minMaxKeyFrames.max,\r\n                        animation.framePerSecond,\r\n                        animationSampleRate,\r\n                        inputs,\r\n                        outputs,\r\n                        minMaxKeyFrames,\r\n                        useQuaternion\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (inputs.length && outputs.length) {\r\n                const result: _IAnimationData = {\r\n                    inputs: inputs,\r\n                    outputs: outputs,\r\n                    samplerInterpolation: interpolation,\r\n                    inputsMin: shouldBakeAnimation ? minMaxKeyFrames.min : Tools.FloatRound(minMaxKeyFrames.min / animation.framePerSecond),\r\n                    inputsMax: shouldBakeAnimation ? minMaxKeyFrames.max : Tools.FloatRound(minMaxKeyFrames.max / animation.framePerSecond),\r\n                };\r\n\r\n                return result;\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private static _DeduceAnimationInfo(animation: Animation): Nullable<_IAnimationInfo> {\r\n        let animationChannelTargetPath: Nullable<AnimationChannelTargetPath> = null;\r\n        let dataAccessorType = AccessorType.VEC3;\r\n        let useQuaternion: boolean = false;\r\n        const property = animation.targetProperty.split(\".\");\r\n        switch (property[0]) {\r\n            case \"scaling\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.SCALE;\r\n                break;\r\n            }\r\n            case \"position\": {\r\n                animationChannelTargetPath = AnimationChannelTargetPath.TRANSLATION;\r\n                break;\r\n            }\r\n            case \"rotation\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"rotationQuaternion\": {\r\n                dataAccessorType = AccessorType.VEC4;\r\n                useQuaternion = true;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.ROTATION;\r\n                break;\r\n            }\r\n            case \"influence\": {\r\n                dataAccessorType = AccessorType.SCALAR;\r\n                animationChannelTargetPath = AnimationChannelTargetPath.WEIGHTS;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`Unsupported animatable property ${property[0]}`);\r\n            }\r\n        }\r\n        if (animationChannelTargetPath) {\r\n            return { animationChannelTargetPath: animationChannelTargetPath, dataAccessorType: dataAccessorType, useQuaternion: useQuaternion };\r\n        } else {\r\n            Tools.Error(\"animation channel target path and data accessor type could be deduced\");\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create node animations from the transform node animations\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAnimationFromNodeAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (_GLTFAnimation._IsTransformable(babylonNode)) {\r\n            if (babylonNode.animations) {\r\n                for (const animation of babylonNode.animations) {\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(animation);\r\n                    if (animationInfo) {\r\n                        glTFAnimation = {\r\n                            name: animation.name,\r\n                            samplers: [],\r\n                            channels: [],\r\n                        };\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animation.name}`,\r\n                            animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                            babylonNode,\r\n                            animation,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            useRightHanded\r\n                        );\r\n                        if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                            idleGLTFAnimations.push(glTFAnimation);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @ignore\r\n     * Create individual morph animations from the mesh's morph target animation tracks\r\n     * @param babylonNode\r\n     * @param runtimeGLTFAnimation\r\n     * @param idleGLTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n        babylonNode: Node,\r\n        runtimeGLTFAnimation: IAnimation,\r\n        idleGLTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        nodes: INode[],\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        useRightHanded: boolean,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonNode instanceof Mesh) {\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n            if (morphTargetManager) {\r\n                for (let i = 0; i < morphTargetManager.numTargets; ++i) {\r\n                    const morphTarget = morphTargetManager.getTarget(i);\r\n                    for (const animation of morphTarget.animations) {\r\n                        if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                            continue;\r\n                        }\r\n                        const combinedAnimation = new Animation(\r\n                            `${animation.name}`,\r\n                            \"influence\",\r\n                            animation.framePerSecond,\r\n                            animation.dataType,\r\n                            animation.loopMode,\r\n                            animation.enableBlending\r\n                        );\r\n                        const combinedAnimationKeys: IAnimationKey[] = [];\r\n                        const animationKeys = animation.getKeys();\r\n\r\n                        for (let j = 0; j < animationKeys.length; ++j) {\r\n                            const animationKey = animationKeys[j];\r\n                            for (let k = 0; k < morphTargetManager.numTargets; ++k) {\r\n                                if (k == i) {\r\n                                    combinedAnimationKeys.push(animationKey);\r\n                                } else {\r\n                                    combinedAnimationKeys.push({ frame: animationKey.frame, value: 0 });\r\n                                }\r\n                            }\r\n                        }\r\n                        combinedAnimation.setKeys(combinedAnimationKeys);\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimation);\r\n                        if (animationInfo) {\r\n                            glTFAnimation = {\r\n                                name: combinedAnimation.name,\r\n                                samplers: [],\r\n                                channels: [],\r\n                            };\r\n                            _GLTFAnimation._AddAnimation(\r\n                                animation.name,\r\n                                animation.hasRunningRuntimeAnimations ? runtimeGLTFAnimation : glTFAnimation,\r\n                                babylonNode,\r\n                                combinedAnimation,\r\n                                animationInfo.dataAccessorType,\r\n                                animationInfo.animationChannelTargetPath,\r\n                                nodeMap,\r\n                                bufferManager,\r\n                                bufferViews,\r\n                                accessors,\r\n                                animationInfo.useQuaternion,\r\n                                animationSampleRate,\r\n                                useRightHanded,\r\n                                morphTargetManager.numTargets\r\n                            );\r\n                            if (glTFAnimation.samplers.length && glTFAnimation.channels.length) {\r\n                                idleGLTFAnimations.push(glTFAnimation);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Create node and morph animations from the animation groups\r\n     * @param babylonScene\r\n     * @param glTFAnimations\r\n     * @param nodeMap\r\n     * @param nodes\r\n     * @param bufferManager\r\n     * @param bufferViews\r\n     * @param accessors\r\n     * @param animationSampleRate\r\n     */\r\n    public static _CreateNodeAndMorphAnimationFromAnimationGroups(\r\n        babylonScene: Scene,\r\n        glTFAnimations: IAnimation[],\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        animationSampleRate: number,\r\n        leftHandedNodes: Set<Node>,\r\n        shouldExportAnimation?: (animation: Animation) => boolean\r\n    ) {\r\n        let glTFAnimation: IAnimation;\r\n        if (babylonScene.animationGroups) {\r\n            const animationGroups = babylonScene.animationGroups;\r\n            for (const animationGroup of animationGroups) {\r\n                const morphAnimations: Map<Mesh, Map<MorphTarget, Animation>> = new Map();\r\n                const sampleAnimations: Map<Mesh, Animation> = new Map();\r\n                const morphAnimationMeshes: Set<Mesh> = new Set();\r\n                const animationGroupFrameDiff = animationGroup.to - animationGroup.from;\r\n                glTFAnimation = {\r\n                    name: animationGroup.name,\r\n                    channels: [],\r\n                    samplers: [],\r\n                };\r\n                for (let i = 0; i < animationGroup.targetedAnimations.length; ++i) {\r\n                    const targetAnimation = animationGroup.targetedAnimations[i];\r\n                    const target = targetAnimation.target;\r\n                    const animation = targetAnimation.animation;\r\n                    if (shouldExportAnimation && !shouldExportAnimation(animation)) {\r\n                        continue;\r\n                    }\r\n\r\n                    const convertToRightHanded = leftHandedNodes.has(target);\r\n\r\n                    if (this._IsTransformable(target) || (target.length === 1 && this._IsTransformable(target[0]))) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonTransformNode = this._IsTransformable(target) ? target : this._IsTransformable(target[0]) ? target[0] : null;\r\n                            if (babylonTransformNode) {\r\n                                _GLTFAnimation._AddAnimation(\r\n                                    `${animation.name}`,\r\n                                    glTFAnimation,\r\n                                    babylonTransformNode,\r\n                                    animation,\r\n                                    animationInfo.dataAccessorType,\r\n                                    animationInfo.animationChannelTargetPath,\r\n                                    nodeMap,\r\n                                    bufferManager,\r\n                                    bufferViews,\r\n                                    accessors,\r\n                                    animationInfo.useQuaternion,\r\n                                    animationSampleRate,\r\n                                    convertToRightHanded\r\n                                );\r\n                            }\r\n                        }\r\n                    } else if (target instanceof MorphTarget || (target.length === 1 && target[0] instanceof MorphTarget)) {\r\n                        const animationInfo = _GLTFAnimation._DeduceAnimationInfo(targetAnimation.animation);\r\n                        if (animationInfo) {\r\n                            const babylonMorphTarget = target instanceof MorphTarget ? target : (target[0] as MorphTarget);\r\n                            if (babylonMorphTarget) {\r\n                                const babylonMorphTargetManager = babylonScene.morphTargetManagers.find((morphTargetManager) => {\r\n                                    for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                                        if (morphTargetManager.getTarget(j) === babylonMorphTarget) {\r\n                                            return true;\r\n                                        }\r\n                                    }\r\n                                    return false;\r\n                                });\r\n                                if (babylonMorphTargetManager) {\r\n                                    const babylonMesh = babylonScene.meshes.find((mesh) => {\r\n                                        return (mesh as Mesh).morphTargetManager === babylonMorphTargetManager;\r\n                                    }) as Mesh;\r\n                                    if (babylonMesh) {\r\n                                        if (!morphAnimations.has(babylonMesh)) {\r\n                                            morphAnimations.set(babylonMesh, new Map());\r\n                                        }\r\n                                        morphAnimations.get(babylonMesh)?.set(babylonMorphTarget, animation);\r\n                                        morphAnimationMeshes.add(babylonMesh);\r\n                                        sampleAnimations.set(babylonMesh, animation);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    } else {\r\n                        // this is the place for the KHR_animation_pointer.\r\n                    }\r\n                }\r\n                morphAnimationMeshes.forEach((mesh) => {\r\n                    const morphTargetManager = mesh.morphTargetManager!;\r\n                    let combinedAnimationGroup: Nullable<Animation> = null;\r\n                    const animationKeys: IAnimationKey[] = [];\r\n                    const sampleAnimation = sampleAnimations.get(mesh)!;\r\n                    const sampleAnimationKeys = sampleAnimation.getKeys();\r\n                    const numAnimationKeys = sampleAnimationKeys.length;\r\n                    /*\r\n                        Due to how glTF expects morph target animation data to be formatted, we need to rearrange the individual morph target animation tracks,\r\n                        such that we have a single animation, where a given keyframe input value has successive output values for each morph target belonging to the manager.\r\n                        See: https://github.com/KhronosGroup/glTF/tree/master/specification/2.0#animations\r\n\r\n                        We do this via constructing a new Animation track, and interleaving the frames of each morph target animation track in the current Animation Group\r\n                        We reuse the Babylon Animation data structure for ease of handling export of cubic spline animation keys, and to reuse the\r\n                        existing _GLTFAnimation.AddAnimation codepath with minimal modification, however the constructed Babylon Animation is NOT intended for use in-engine.\r\n                    */\r\n                    for (let i = 0; i < numAnimationKeys; ++i) {\r\n                        for (let j = 0; j < morphTargetManager.numTargets; ++j) {\r\n                            const morphTarget = morphTargetManager.getTarget(j);\r\n                            const animationsByMorphTarget = morphAnimations.get(mesh);\r\n                            if (animationsByMorphTarget) {\r\n                                const morphTargetAnimation = animationsByMorphTarget.get(morphTarget);\r\n                                if (morphTargetAnimation) {\r\n                                    if (!combinedAnimationGroup) {\r\n                                        combinedAnimationGroup = new Animation(\r\n                                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                                            \"influence\",\r\n                                            morphTargetAnimation.framePerSecond,\r\n                                            Animation.ANIMATIONTYPE_FLOAT,\r\n                                            morphTargetAnimation.loopMode,\r\n                                            morphTargetAnimation.enableBlending\r\n                                        );\r\n                                    }\r\n                                    animationKeys.push(morphTargetAnimation.getKeys()[i]);\r\n                                } else {\r\n                                    animationKeys.push({\r\n                                        frame: animationGroup.from + (animationGroupFrameDiff / numAnimationKeys) * i,\r\n                                        value: morphTarget.influence,\r\n                                        inTangent: sampleAnimationKeys[0].inTangent ? 0 : undefined,\r\n                                        outTangent: sampleAnimationKeys[0].outTangent ? 0 : undefined,\r\n                                    });\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    combinedAnimationGroup!.setKeys(animationKeys);\r\n                    const animationInfo = _GLTFAnimation._DeduceAnimationInfo(combinedAnimationGroup!);\r\n                    if (animationInfo) {\r\n                        _GLTFAnimation._AddAnimation(\r\n                            `${animationGroup.name}_${mesh.name}_MorphWeightAnimation`,\r\n                            glTFAnimation,\r\n                            mesh,\r\n                            combinedAnimationGroup!,\r\n                            animationInfo.dataAccessorType,\r\n                            animationInfo.animationChannelTargetPath,\r\n                            nodeMap,\r\n                            bufferManager,\r\n                            bufferViews,\r\n                            accessors,\r\n                            animationInfo.useQuaternion,\r\n                            animationSampleRate,\r\n                            false,\r\n                            morphTargetManager?.numTargets\r\n                        );\r\n                    }\r\n                });\r\n                if (glTFAnimation.channels.length && glTFAnimation.samplers.length) {\r\n                    glTFAnimations.push(glTFAnimation);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private static _AddAnimation(\r\n        name: string,\r\n        glTFAnimation: IAnimation,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        dataAccessorType: AccessorType,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        nodeMap: Map<Node, number>,\r\n        bufferManager: BufferManager,\r\n        bufferViews: IBufferView[],\r\n        accessors: IAccessor[],\r\n        useQuaternion: boolean,\r\n        animationSampleRate: number,\r\n        convertToRightHanded: boolean,\r\n        morphAnimationChannels?: number\r\n    ) {\r\n        const animationData = _GLTFAnimation._CreateNodeAnimation(babylonTransformNode, animation, animationChannelTargetPath, useQuaternion, animationSampleRate);\r\n        let bufferView: IBufferView;\r\n        let accessor: IAccessor;\r\n        let keyframeAccessorIndex: number;\r\n        let dataAccessorIndex: number;\r\n        let animationSampler: IAnimationSampler;\r\n        let animationChannel: IAnimationChannel;\r\n\r\n        if (animationData) {\r\n            /*\r\n             * Now that we have the glTF converted morph target animation data,\r\n             * we can remove redundant input data so that we have n input frames,\r\n             * and morphAnimationChannels * n output frames\r\n             */\r\n            if (morphAnimationChannels) {\r\n                let index = 0;\r\n                let currentInput: number = 0;\r\n                const newInputs: number[] = [];\r\n                while (animationData.inputs.length > 0) {\r\n                    currentInput = animationData.inputs.shift()!;\r\n                    if (index % morphAnimationChannels == 0) {\r\n                        newInputs.push(currentInput);\r\n                    }\r\n                    index++;\r\n                }\r\n                animationData.inputs = newInputs;\r\n            }\r\n\r\n            const nodeIndex = nodeMap.get(babylonTransformNode);\r\n\r\n            // Create buffer view and accessor for key frames.\r\n            const inputData = new Float32Array(animationData.inputs);\r\n            bufferView = bufferManager.createBufferView(inputData);\r\n            accessor = bufferManager.createAccessor(bufferView, AccessorType.SCALAR, AccessorComponentType.FLOAT, animationData.inputs.length, undefined, {\r\n                min: [animationData.inputsMin],\r\n                max: [animationData.inputsMax],\r\n            });\r\n            accessors.push(accessor);\r\n            keyframeAccessorIndex = accessors.length - 1;\r\n\r\n            // Perform conversions on keyed values while also building their buffer.\r\n            const rotationQuaternion = new Quaternion();\r\n            const eulerVec3 = new Vector3();\r\n            const position = new Vector3();\r\n            const isCamera = babylonTransformNode instanceof Camera;\r\n\r\n            const elementCount = GetAccessorElementCount(dataAccessorType);\r\n            const outputData = new Float32Array(animationData.outputs.length * elementCount);\r\n            animationData.outputs.forEach(function (output: number[], index: number) {\r\n                let outputToWrite: number[] = output;\r\n                switch (animationChannelTargetPath) {\r\n                    case AnimationChannelTargetPath.TRANSLATION:\r\n                        if (convertToRightHanded) {\r\n                            Vector3.FromArrayToRef(output, 0, position);\r\n                            ConvertToRightHandedPosition(position);\r\n                            position.toArray(outputToWrite);\r\n                        }\r\n                        break;\r\n                    case AnimationChannelTargetPath.ROTATION:\r\n                        if (output.length === 4) {\r\n                            Quaternion.FromArrayToRef(output, 0, rotationQuaternion);\r\n                        } else {\r\n                            outputToWrite = new Array(4); // Will need 4, not 3, for a quaternion\r\n                            Vector3.FromArrayToRef(output, 0, eulerVec3);\r\n                            Quaternion.FromEulerVectorToRef(eulerVec3, rotationQuaternion);\r\n                        }\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedRotation(rotationQuaternion);\r\n                            if (isCamera) {\r\n                                Rotate180Y(rotationQuaternion);\r\n                            }\r\n                        }\r\n\r\n                        rotationQuaternion.toArray(outputToWrite);\r\n                        break;\r\n                }\r\n                outputData.set(outputToWrite, index * elementCount);\r\n            });\r\n\r\n            // Create buffer view and accessor for keyed values.\r\n            bufferView = bufferManager.createBufferView(outputData);\r\n            accessor = bufferManager.createAccessor(bufferView, dataAccessorType, AccessorComponentType.FLOAT, animationData.outputs.length);\r\n            accessors.push(accessor);\r\n            dataAccessorIndex = accessors.length - 1;\r\n\r\n            // create sampler\r\n            animationSampler = {\r\n                interpolation: animationData.samplerInterpolation,\r\n                input: keyframeAccessorIndex,\r\n                output: dataAccessorIndex,\r\n            };\r\n            glTFAnimation.samplers.push(animationSampler);\r\n\r\n            // create channel\r\n            animationChannel = {\r\n                sampler: glTFAnimation.samplers.length - 1,\r\n                target: {\r\n                    node: nodeIndex,\r\n                    path: animationChannelTargetPath,\r\n                },\r\n            };\r\n            glTFAnimation.channels.push(animationChannel);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create a baked animation\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation corresponding to the BabylonJS mesh\r\n     * @param animationChannelTargetPath animation target channel\r\n     * @param minFrame minimum animation frame\r\n     * @param maxFrame maximum animation frame\r\n     * @param fps frames per second of the animation\r\n     * @param sampleRate\r\n     * @param inputs input key frames of the animation\r\n     * @param outputs output key frame data of the animation\r\n     * @param minMaxFrames\r\n     * @param minMaxFrames.min\r\n     * @param minMaxFrames.max\r\n     * @param useQuaternion specifies if quaternions should be used\r\n     */\r\n    private static _CreateBakedAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        minFrame: number,\r\n        maxFrame: number,\r\n        fps: number,\r\n        sampleRate: number,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        minMaxFrames: { min: number; max: number },\r\n        useQuaternion: boolean\r\n    ) {\r\n        let value: number | Vector3 | Quaternion;\r\n        const quaternionCache: Quaternion = Quaternion.Identity();\r\n        let previousTime: Nullable<number> = null;\r\n        let time: number;\r\n        let maxUsedFrame: Nullable<number> = null;\r\n        let currKeyFrame: Nullable<IAnimationKey> = null;\r\n        let nextKeyFrame: Nullable<IAnimationKey> = null;\r\n        let prevKeyFrame: Nullable<IAnimationKey> = null;\r\n        let endFrame: Nullable<number> = null;\r\n        minMaxFrames.min = Tools.FloatRound(minFrame / fps);\r\n\r\n        const keyFrames = animation.getKeys();\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            endFrame = null;\r\n            currKeyFrame = keyFrames[i];\r\n\r\n            if (i + 1 < length) {\r\n                nextKeyFrame = keyFrames[i + 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(nextKeyFrame.value)) || currKeyFrame.value === nextKeyFrame.value) {\r\n                    if (i === 0) {\r\n                        // set the first frame to itself\r\n                        endFrame = currKeyFrame.frame;\r\n                    } else {\r\n                        continue;\r\n                    }\r\n                } else {\r\n                    endFrame = nextKeyFrame.frame;\r\n                }\r\n            } else {\r\n                // at the last key frame\r\n                prevKeyFrame = keyFrames[i - 1];\r\n                if ((currKeyFrame.value.equals && currKeyFrame.value.equals(prevKeyFrame.value)) || currKeyFrame.value === prevKeyFrame.value) {\r\n                    continue;\r\n                } else {\r\n                    endFrame = maxFrame;\r\n                }\r\n            }\r\n            if (endFrame) {\r\n                for (let f = currKeyFrame.frame; f <= endFrame; f += sampleRate) {\r\n                    time = Tools.FloatRound(f / fps);\r\n                    if (time === previousTime) {\r\n                        continue;\r\n                    }\r\n                    previousTime = time;\r\n                    maxUsedFrame = time;\r\n                    const state = {\r\n                        key: 0,\r\n                        repeatCount: 0,\r\n                        loopMode: animation.loopMode,\r\n                    };\r\n                    value = animation._interpolate(f, state);\r\n\r\n                    _GLTFAnimation._SetInterpolatedValue(babylonTransformNode, value, time, animation, animationChannelTargetPath, quaternionCache, inputs, outputs, useQuaternion);\r\n                }\r\n            }\r\n        }\r\n        if (maxUsedFrame) {\r\n            minMaxFrames.max = maxUsedFrame;\r\n        }\r\n    }\r\n\r\n    private static _ConvertFactorToVector3OrQuaternion(\r\n        factor: number,\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): Vector3 | Quaternion {\r\n        const basePositionRotationOrScale = _GLTFAnimation._GetBasePositionRotationOrScale(babylonTransformNode, animationChannelTargetPath, useQuaternion);\r\n        // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n        const property = animation.targetProperty.split(\".\");\r\n        const componentName = property ? property[1] : \"\"; // x, y, z, or w component\r\n        const value = useQuaternion ? Quaternion.FromArray(basePositionRotationOrScale).normalize() : Vector3.FromArray(basePositionRotationOrScale);\r\n\r\n        switch (componentName) {\r\n            case \"x\":\r\n            case \"y\":\r\n            case \"z\": {\r\n                value[componentName] = factor;\r\n                break;\r\n            }\r\n            case \"w\": {\r\n                (value as Quaternion).w = factor;\r\n                break;\r\n            }\r\n            default: {\r\n                Tools.Error(`glTFAnimation: Unsupported component name \"${componentName}\"!`);\r\n            }\r\n        }\r\n\r\n        return value;\r\n    }\r\n\r\n    private static _SetInterpolatedValue(\r\n        babylonTransformNode: Node,\r\n        value: number | Vector3 | Quaternion,\r\n        time: number,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        quaternionCache: Quaternion,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        let cacheValue: Vector3 | Quaternion | number;\r\n        inputs.push(time);\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n            outputs.push([value as number]);\r\n            return;\r\n        }\r\n\r\n        if (animation.dataType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            value = this._ConvertFactorToVector3OrQuaternion(value as number, babylonTransformNode, animation, animationChannelTargetPath, useQuaternion);\r\n        }\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                quaternionCache = value as Quaternion;\r\n            } else {\r\n                cacheValue = value as Vector3;\r\n                Quaternion.RotationYawPitchRollToRef(cacheValue.y, cacheValue.x, cacheValue.z, quaternionCache);\r\n            }\r\n            outputs.push(quaternionCache.asArray());\r\n        } else {\r\n            // scaling and position animation\r\n            cacheValue = value as Vector3;\r\n            outputs.push(cacheValue.asArray());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates linear animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateLinearOrStepAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        for (const keyFrame of animation.getKeys()) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates cubic spline animation from the animation key frames\r\n     * @param babylonTransformNode BabylonJS mesh\r\n     * @param animation BabylonJS animation\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param inputs Array to store the key frame times\r\n     * @param outputs Array to store the key frame data\r\n     * @param useQuaternion Specifies if quaternions are used in the animation\r\n     */\r\n    private static _CreateCubicSplineAnimation(\r\n        babylonTransformNode: Node,\r\n        animation: Animation,\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        inputs: number[],\r\n        outputs: number[][],\r\n        useQuaternion: boolean\r\n    ) {\r\n        animation.getKeys().forEach(function (keyFrame) {\r\n            inputs.push(keyFrame.frame / animation.framePerSecond); // keyframes in seconds.\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.INTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n            _GLTFAnimation._AddKeyframeValue(keyFrame, animation, outputs, animationChannelTargetPath, babylonTransformNode, useQuaternion);\r\n\r\n            _GLTFAnimation._AddSplineTangent(_TangentType.OUTTANGENT, outputs, animationChannelTargetPath, AnimationSamplerInterpolation.CUBICSPLINE, keyFrame, useQuaternion);\r\n        });\r\n    }\r\n\r\n    private static _GetBasePositionRotationOrScale(babylonTransformNode: Node, animationChannelTargetPath: AnimationChannelTargetPath, useQuaternion: boolean) {\r\n        let basePositionRotationOrScale: number[];\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n            if (useQuaternion) {\r\n                const q = (babylonTransformNode as TransformNode).rotationQuaternion;\r\n                basePositionRotationOrScale = (q ?? Quaternion.Identity()).asArray();\r\n            } else {\r\n                const r: Vector3 = (babylonTransformNode as TransformNode).rotation;\r\n                basePositionRotationOrScale = (r ?? Vector3.Zero()).asArray();\r\n            }\r\n        } else if (animationChannelTargetPath === AnimationChannelTargetPath.TRANSLATION) {\r\n            const p: Vector3 = (babylonTransformNode as TransformNode).position;\r\n            basePositionRotationOrScale = (p ?? Vector3.Zero()).asArray();\r\n        } else {\r\n            // scale\r\n            const s: Vector3 = (babylonTransformNode as TransformNode).scaling;\r\n            basePositionRotationOrScale = (s ?? Vector3.One()).asArray();\r\n        }\r\n        return basePositionRotationOrScale;\r\n    }\r\n\r\n    /**\r\n     * Adds a key frame value\r\n     * @param keyFrame\r\n     * @param animation\r\n     * @param outputs\r\n     * @param animationChannelTargetPath\r\n     * @param babylonTransformNode\r\n     * @param useQuaternion\r\n     */\r\n    private static _AddKeyframeValue(\r\n        keyFrame: IAnimationKey,\r\n        animation: Animation,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        babylonTransformNode: Node,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let newPositionRotationOrScale: Nullable<Vector3 | Quaternion | number>;\r\n        const animationType = animation.dataType;\r\n        if (animationType === Animation.ANIMATIONTYPE_VECTOR3) {\r\n            let value = keyFrame.value.asArray();\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                const array = Vector3.FromArray(value);\r\n                const rotationQuaternion = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z);\r\n                value = rotationQuaternion.asArray();\r\n            }\r\n            outputs.push(value); // scale  vector.\r\n        } else if (animationType === Animation.ANIMATIONTYPE_FLOAT) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                outputs.push([keyFrame.value]);\r\n            } else {\r\n                // handles single component x, y, z or w component animation by using a base property and animating over a component.\r\n                newPositionRotationOrScale = this._ConvertFactorToVector3OrQuaternion(\r\n                    keyFrame.value as number,\r\n                    babylonTransformNode,\r\n                    animation,\r\n                    animationChannelTargetPath,\r\n                    useQuaternion\r\n                );\r\n                if (newPositionRotationOrScale) {\r\n                    if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                        const posRotScale = useQuaternion\r\n                            ? (newPositionRotationOrScale as Quaternion)\r\n                            : Quaternion.RotationYawPitchRoll(newPositionRotationOrScale.y, newPositionRotationOrScale.x, newPositionRotationOrScale.z).normalize();\r\n                        outputs.push(posRotScale.asArray());\r\n                    }\r\n                    outputs.push(newPositionRotationOrScale.asArray());\r\n                }\r\n            }\r\n        } else if (animationType === Animation.ANIMATIONTYPE_QUATERNION) {\r\n            outputs.push((keyFrame.value as Quaternion).normalize().asArray());\r\n        } else {\r\n            Tools.Error(\"glTFAnimation: Unsupported key frame values for animation!\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * Determine the interpolation based on the key frames\r\n     * @param keyFrames\r\n     * @param animationChannelTargetPath\r\n     * @param useQuaternion\r\n     */\r\n    private static _DeduceInterpolation(\r\n        keyFrames: IAnimationKey[],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        useQuaternion: boolean\r\n    ): { interpolationType: AnimationSamplerInterpolation; shouldBakeAnimation: boolean } {\r\n        let interpolationType: AnimationSamplerInterpolation | undefined;\r\n        let shouldBakeAnimation = false;\r\n        let key: IAnimationKey;\r\n\r\n        if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION && !useQuaternion) {\r\n            return { interpolationType: AnimationSamplerInterpolation.LINEAR, shouldBakeAnimation: true };\r\n        }\r\n\r\n        for (let i = 0, length = keyFrames.length; i < length; ++i) {\r\n            key = keyFrames[i];\r\n            if (key.inTangent || key.outTangent) {\r\n                if (interpolationType) {\r\n                    if (interpolationType !== AnimationSamplerInterpolation.CUBICSPLINE) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    interpolationType = AnimationSamplerInterpolation.CUBICSPLINE;\r\n                }\r\n            } else {\r\n                if (interpolationType) {\r\n                    if (\r\n                        interpolationType === AnimationSamplerInterpolation.CUBICSPLINE ||\r\n                        (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP && interpolationType !== AnimationSamplerInterpolation.STEP)\r\n                    ) {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                        shouldBakeAnimation = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    if (key.interpolation && key.interpolation === AnimationKeyInterpolation.STEP) {\r\n                        interpolationType = AnimationSamplerInterpolation.STEP;\r\n                    } else {\r\n                        interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (!interpolationType) {\r\n            interpolationType = AnimationSamplerInterpolation.LINEAR;\r\n        }\r\n\r\n        return { interpolationType: interpolationType, shouldBakeAnimation: shouldBakeAnimation };\r\n    }\r\n\r\n    /**\r\n     * Adds an input tangent or output tangent to the output data\r\n     * If an input tangent or output tangent is missing, it uses the zero vector or zero quaternion\r\n     * @param tangentType Specifies which type of tangent to handle (inTangent or outTangent)\r\n     * @param outputs The animation data by keyframe\r\n     * @param animationChannelTargetPath The target animation channel\r\n     * @param interpolation The interpolation type\r\n     * @param keyFrame The key frame with the animation data\r\n     * @param useQuaternion Specifies if quaternions are used\r\n     */\r\n    private static _AddSplineTangent(\r\n        tangentType: _TangentType,\r\n        outputs: number[][],\r\n        animationChannelTargetPath: AnimationChannelTargetPath,\r\n        interpolation: AnimationSamplerInterpolation,\r\n        keyFrame: IAnimationKey,\r\n        useQuaternion: boolean\r\n    ) {\r\n        let tangent: number[];\r\n        const tangentValue: Vector3 | Quaternion | number = tangentType === _TangentType.INTANGENT ? keyFrame.inTangent : keyFrame.outTangent;\r\n        if (interpolation === AnimationSamplerInterpolation.CUBICSPLINE) {\r\n            if (animationChannelTargetPath === AnimationChannelTargetPath.ROTATION) {\r\n                if (tangentValue) {\r\n                    if (useQuaternion) {\r\n                        tangent = (tangentValue as Quaternion).asArray();\r\n                    } else {\r\n                        const array = tangentValue as Vector3;\r\n                        tangent = Quaternion.RotationYawPitchRoll(array.y, array.x, array.z).asArray();\r\n                    }\r\n                } else {\r\n                    tangent = [0, 0, 0, 0];\r\n                }\r\n            } else if (animationChannelTargetPath === AnimationChannelTargetPath.WEIGHTS) {\r\n                if (tangentValue) {\r\n                    tangent = [tangentValue as number];\r\n                } else {\r\n                    tangent = [0];\r\n                }\r\n            } else {\r\n                if (tangentValue) {\r\n                    tangent = (tangentValue as Vector3).asArray();\r\n                } else {\r\n                    tangent = [0, 0, 0];\r\n                }\r\n            }\r\n\r\n            outputs.push(tangent);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the minimum and maximum key frames' frame values\r\n     * @param keyFrames animation key frames\r\n     * @returns the minimum and maximum key frame value\r\n     */\r\n    private static _CalculateMinMaxKeyFrames(keyFrames: IAnimationKey[]): { min: number; max: number } {\r\n        let min: number = Infinity;\r\n        let max: number = -Infinity;\r\n        keyFrames.forEach(function (keyFrame) {\r\n            min = Math.min(min, keyFrame.frame);\r\n            max = Math.max(max, keyFrame.frame);\r\n        });\r\n\r\n        return { min: min, max: max };\r\n    }\r\n}\r\n","import type { IBufferView, IAccessor } from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType } from \"babylonjs-gltf2interface\";\r\nimport type { MorphTarget } from \"core/Morph/morphTarget\";\r\nimport type { BufferManager } from \"./bufferManager\";\r\n\r\nimport { NormalizeTangent } from \"./glTFUtilities\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\n/**\r\n * Interface to store morph target information.\r\n * @internal\r\n */\r\nexport interface IMorphTargetData {\r\n    attributes: Record<string, number>;\r\n    influence: number;\r\n    name: string;\r\n}\r\n\r\nexport function BuildMorphTargetBuffers(\r\n    morphTarget: MorphTarget,\r\n    mesh: AbstractMesh,\r\n    bufferManager: BufferManager,\r\n    bufferViews: IBufferView[],\r\n    accessors: IAccessor[],\r\n    convertToRightHanded: boolean\r\n): IMorphTargetData {\r\n    const result: IMorphTargetData = {\r\n        attributes: {},\r\n        influence: morphTarget.influence,\r\n        name: morphTarget.name,\r\n    };\r\n\r\n    const geometry = mesh.geometry;\r\n    if (!geometry) {\r\n        Tools.Warn(\"Attempted to export morph target data from a mesh without geometry. This should not happen.\");\r\n        return result;\r\n    }\r\n\r\n    const flipX = convertToRightHanded ? -1 : 1;\r\n    const floatSize = 4;\r\n    const difference = Vector3.Zero();\r\n    let vertexStart = 0;\r\n    let vertexCount = 0;\r\n\r\n    if (morphTarget.hasPositions) {\r\n        const morphPositions = morphTarget.getPositions()!;\r\n        const originalPositions = geometry.getVerticesData(VertexBuffer.PositionKind); // Bypasses any instance data of mesh\r\n\r\n        if (originalPositions) {\r\n            const positionData = new Float32Array(originalPositions.length);\r\n            const min = [Infinity, Infinity, Infinity];\r\n            const max = [-Infinity, -Infinity, -Infinity];\r\n            vertexCount = originalPositions.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalPosition = Vector3.FromArray(originalPositions, i * 3);\r\n                const morphPosition = Vector3.FromArray(morphPositions, i * 3);\r\n                morphPosition.subtractToRef(originalPosition, difference);\r\n                difference.x *= flipX;\r\n\r\n                min[0] = Math.min(min[0], difference.x);\r\n                max[0] = Math.max(max[0], difference.x);\r\n\r\n                min[1] = Math.min(min[1], difference.y);\r\n                max[1] = Math.max(max[1], difference.y);\r\n\r\n                min[2] = Math.min(min[2], difference.z);\r\n                max[2] = Math.max(max[2], difference.z);\r\n\r\n                positionData[i * 3] = difference.x;\r\n                positionData[i * 3 + 1] = difference.y;\r\n                positionData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(positionData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphPositions.length / 3, 0, { min, max });\r\n            accessors.push(accessor);\r\n            result.attributes[\"POSITION\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target positions for mesh ${mesh.name} were not exported. Mesh does not have position vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasNormals) {\r\n        const morphNormals = morphTarget.getNormals()!;\r\n        const originalNormals = geometry.getVerticesData(VertexBuffer.NormalKind);\r\n\r\n        if (originalNormals) {\r\n            const normalData = new Float32Array(originalNormals.length);\r\n            vertexCount = originalNormals.length / 3;\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                const originalNormal = Vector3.FromArray(originalNormals, i * 3).normalize();\r\n                const morphNormal = Vector3.FromArray(morphNormals, i * 3).normalize();\r\n                morphNormal.subtractToRef(originalNormal, difference);\r\n\r\n                normalData[i * 3] = difference.x * flipX;\r\n                normalData[i * 3 + 1] = difference.y;\r\n                normalData[i * 3 + 2] = difference.z;\r\n            }\r\n\r\n            const bufferView = bufferManager.createBufferView(normalData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, morphNormals.length / 3, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"NORMAL\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target normals for mesh ${mesh.name} were not exported. Mesh does not have normals vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasTangents) {\r\n        const morphTangents = morphTarget.getTangents()!;\r\n        const originalTangents = geometry.getVerticesData(VertexBuffer.TangentKind);\r\n\r\n        if (originalTangents) {\r\n            vertexCount = originalTangents.length / 4;\r\n            const tangentData = new Float32Array(vertexCount * 3);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                // Only read the x, y, z components and ignore w\r\n                const originalTangent = Vector3.FromArray(originalTangents, i * 4);\r\n                NormalizeTangent(originalTangent);\r\n\r\n                // Morph target tangents omit the w component so it won't be present in the data\r\n                const morphTangent = Vector3.FromArray(morphTangents, i * 3);\r\n                NormalizeTangent(morphTangent);\r\n\r\n                morphTangent.subtractToRef(originalTangent, difference);\r\n                tangentData[i * 3] = difference.x * flipX;\r\n                tangentData[i * 3 + 1] = difference.y;\r\n                tangentData[i * 3 + 2] = difference.z;\r\n            }\r\n            const bufferView = bufferManager.createBufferView(tangentData, floatSize * 3);\r\n            const accessor = bufferManager.createAccessor(bufferView, AccessorType.VEC3, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"TANGENT\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target tangents for mesh ${mesh.name} were not exported. Mesh does not have tangents vertex data`);\r\n        }\r\n    }\r\n\r\n    if (morphTarget.hasColors) {\r\n        const morphColors = morphTarget.getColors()!;\r\n        const originalColors = geometry.getVerticesData(VertexBuffer.ColorKind);\r\n        const buffer = geometry.getVertexBuffer(VertexBuffer.ColorKind);\r\n\r\n        if (originalColors && buffer) {\r\n            const componentSize = buffer.getSize();\r\n\r\n            vertexCount = originalColors.length / componentSize;\r\n            const colorData = new Float32Array(vertexCount * componentSize);\r\n            vertexStart = 0;\r\n            for (let i = vertexStart; i < vertexCount; ++i) {\r\n                if (componentSize === 3) {\r\n                    const originalColor = Vector3.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector3.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference);\r\n                    colorData[i * 3] = difference.x;\r\n                    colorData[i * 3 + 1] = difference.y;\r\n                    colorData[i * 3 + 2] = difference.z;\r\n                } else if (componentSize === 4) {\r\n                    const difference4 = new Vector4();\r\n                    const originalColor = Vector4.FromArray(originalColors, i * componentSize);\r\n                    const morphColor = Vector4.FromArray(morphColors, i * componentSize);\r\n\r\n                    morphColor.subtractToRef(originalColor, difference4);\r\n                    colorData[i * 4] = difference4.x;\r\n                    colorData[i * 4 + 1] = difference4.y;\r\n                    colorData[i * 4 + 2] = difference4.z;\r\n                    colorData[i * 4 + 3] = difference4.w;\r\n                } else {\r\n                    Tools.Warn(`Unsupported number of components for color attribute: ${componentSize}`);\r\n                }\r\n            }\r\n            const bufferView = bufferManager.createBufferView(colorData, floatSize * componentSize);\r\n            const accessor = bufferManager.createAccessor(bufferView, componentSize === 3 ? AccessorType.VEC3 : AccessorType.VEC4, AccessorComponentType.FLOAT, vertexCount, 0);\r\n            accessors.push(accessor);\r\n            result.attributes[\"COLOR_0\"] = accessors.length - 1;\r\n        } else {\r\n            Tools.Warn(`Morph target colors for mesh ${mesh.name} were not exported. Mesh does not have colors vertex data`);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\n","import type {\r\n    IBufferView,\r\n    IAccessor,\r\n    INode,\r\n    IScene,\r\n    IMesh,\r\n    IMaterial,\r\n    ITexture,\r\n    IImage,\r\n    ISampler,\r\n    IAnimation,\r\n    IMeshPrimitive,\r\n    IBuffer,\r\n    IGLTF,\r\n    ITextureInfo,\r\n    ISkin,\r\n    ICamera,\r\n} from \"babylonjs-gltf2interface\";\r\nimport { AccessorComponentType, AccessorType, CameraType, ImageMimeType } from \"babylonjs-gltf2interface\";\r\nimport type { FloatArray, IndicesArray, Nullable } from \"core/types\";\r\nimport { TmpVectors, Quaternion } from \"core/Maths/math.vector\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Buffer } from \"core/Buffers/buffer\";\r\nimport { VertexBuffer } from \"core/Buffers/buffer\";\r\nimport type { Node } from \"core/node\";\r\nimport { TransformNode } from \"core/Meshes/transformNode\";\r\nimport type { SubMesh } from \"core/Meshes/subMesh\";\r\nimport type { Mesh } from \"core/Meshes/mesh\";\r\nimport { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { InstancedMesh } from \"core/Meshes/instancedMesh\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport { Material } from \"core/Materials/material\";\r\nimport { Engine } from \"core/Engines/engine\";\r\nimport type { Scene } from \"core/scene\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\nimport type { IGLTFExporterExtensionV2 } from \"./glTFExporterExtension\";\r\nimport { GLTFMaterialExporter } from \"./glTFMaterialExporter\";\r\nimport type { IExportOptions } from \"./glTFSerializer\";\r\nimport { GLTFData } from \"./glTFData\";\r\nimport {\r\n    ConvertToRightHandedPosition,\r\n    ConvertToRightHandedRotation,\r\n    DataArrayToUint8Array,\r\n    GetAccessorType,\r\n    GetAttributeType,\r\n    GetMinMax,\r\n    GetPrimitiveMode,\r\n    IsNoopNode,\r\n    IsTriangleFillMode,\r\n    IsChildCollapsible,\r\n    FloatsNeed16BitInteger,\r\n    IsStandardVertexAttribute,\r\n    IndicesArrayToTypedArray,\r\n    GetVertexBufferInfo,\r\n    CollapseChildIntoParent,\r\n    Rotate180Y,\r\n    DefaultTranslation,\r\n    DefaultScale,\r\n    DefaultRotation,\r\n} from \"./glTFUtilities\";\r\nimport { BufferManager } from \"./bufferManager\";\r\nimport { Camera } from \"core/Cameras/camera\";\r\nimport { MultiMaterial } from \"core/Materials/multiMaterial\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { EnumerateFloatValues, AreIndices32Bits } from \"core/Buffers/bufferUtils\";\r\nimport type { Bone, Skeleton } from \"core/Bones\";\r\nimport { _GLTFAnimation } from \"./glTFAnimation\";\r\nimport type { MorphTarget } from \"core/Morph\";\r\nimport { BuildMorphTargetBuffers } from \"./glTFMorphTargetsUtilities\";\r\nimport type { IMorphTargetData } from \"./glTFMorphTargetsUtilities\";\r\nimport { LinesMesh } from \"core/Meshes/linesMesh\";\r\nimport { GreasedLineBaseMesh } from \"core/Meshes/GreasedLine/greasedLineBaseMesh\";\r\nimport { Color3, Color4 } from \"core/Maths/math.color\";\r\nimport { TargetCamera } from \"core/Cameras/targetCamera\";\r\nimport { Epsilon } from \"core/Maths/math.constants\";\r\n\r\nclass ExporterState {\r\n    // Babylon indices array, start, count, offset, flip -> glTF accessor index\r\n    private _indicesAccessorMap = new Map<Nullable<IndicesArray>, Map<number, Map<number, Map<number, Map<boolean, number>>>>>();\r\n\r\n    // Babylon buffer -> glTF buffer view\r\n    private _vertexBufferViewMap = new Map<Buffer, IBufferView>();\r\n\r\n    // Babylon vertex buffer, start, count -> glTF accessor index\r\n    private _vertexAccessorMap = new Map<VertexBuffer, Map<number, Map<number, number>>>();\r\n\r\n    private _remappedBufferView = new Map<Buffer, Map<VertexBuffer, IBufferView>>();\r\n\r\n    private _meshMorphTargetMap = new Map<AbstractMesh, IMorphTargetData[]>();\r\n\r\n    private _vertexMapColorAlpha = new Map<VertexBuffer, boolean>();\r\n\r\n    private _exportedNodes = new Set<Node>();\r\n\r\n    // Babylon mesh -> glTF mesh index\r\n    private _meshMap = new Map<AbstractMesh, number>();\r\n\r\n    public constructor(convertToRightHanded: boolean, wasAddedByNoopNode: boolean) {\r\n        this.convertToRightHanded = convertToRightHanded;\r\n        this.wasAddedByNoopNode = wasAddedByNoopNode;\r\n    }\r\n\r\n    public readonly convertToRightHanded: boolean;\r\n\r\n    public readonly wasAddedByNoopNode: boolean;\r\n\r\n    // Only used when convertToRightHanded is true.\r\n    public readonly convertedToRightHandedBuffers = new Map<Buffer, Uint8Array>();\r\n\r\n    public getIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean): number | undefined {\r\n        return this._indicesAccessorMap.get(indices)?.get(start)?.get(count)?.get(offset)?.get(flip);\r\n    }\r\n\r\n    public setIndicesAccessor(indices: Nullable<IndicesArray>, start: number, count: number, offset: number, flip: boolean, accessorIndex: number): void {\r\n        let map1 = this._indicesAccessorMap.get(indices);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, Map<number, Map<boolean, number>>>>();\r\n            this._indicesAccessorMap.set(indices, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, Map<number, Map<boolean, number>>>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        let map3 = map2.get(count);\r\n        if (!map3) {\r\n            map3 = new Map<number, Map<boolean, number>>();\r\n            map2.set(count, map3);\r\n        }\r\n\r\n        let map4 = map3.get(offset);\r\n        if (!map4) {\r\n            map4 = new Map<boolean, number>();\r\n            map3.set(offset, map4);\r\n        }\r\n\r\n        map4.set(flip, accessorIndex);\r\n    }\r\n\r\n    public pushExportedNode(node: Node) {\r\n        if (!this._exportedNodes.has(node)) {\r\n            this._exportedNodes.add(node);\r\n        }\r\n    }\r\n\r\n    public getNodesSet(): Set<Node> {\r\n        return this._exportedNodes;\r\n    }\r\n\r\n    public getVertexBufferView(buffer: Buffer): IBufferView | undefined {\r\n        return this._vertexBufferViewMap.get(buffer);\r\n    }\r\n\r\n    public setVertexBufferView(buffer: Buffer, bufferView: IBufferView): void {\r\n        this._vertexBufferViewMap.set(buffer, bufferView);\r\n    }\r\n\r\n    public setRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer, bufferView: IBufferView) {\r\n        this._remappedBufferView.set(buffer, new Map<VertexBuffer, IBufferView>());\r\n        this._remappedBufferView.get(buffer)!.set(vertexBuffer, bufferView);\r\n    }\r\n\r\n    public getRemappedBufferView(buffer: Buffer, vertexBuffer: VertexBuffer): IBufferView | undefined {\r\n        return this._remappedBufferView.get(buffer)?.get(vertexBuffer);\r\n    }\r\n\r\n    public getVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number): number | undefined {\r\n        return this._vertexAccessorMap.get(vertexBuffer)?.get(start)?.get(count);\r\n    }\r\n\r\n    public setVertexAccessor(vertexBuffer: VertexBuffer, start: number, count: number, accessorIndex: number): void {\r\n        let map1 = this._vertexAccessorMap.get(vertexBuffer);\r\n        if (!map1) {\r\n            map1 = new Map<number, Map<number, number>>();\r\n            this._vertexAccessorMap.set(vertexBuffer, map1);\r\n        }\r\n\r\n        let map2 = map1.get(start);\r\n        if (!map2) {\r\n            map2 = new Map<number, number>();\r\n            map1.set(start, map2);\r\n        }\r\n\r\n        map2.set(count, accessorIndex);\r\n    }\r\n\r\n    public hasVertexColorAlpha(vertexBuffer: VertexBuffer): boolean {\r\n        return this._vertexMapColorAlpha.get(vertexBuffer) || false;\r\n    }\r\n\r\n    public setHasVertexColorAlpha(vertexBuffer: VertexBuffer, hasAlpha: boolean) {\r\n        return this._vertexMapColorAlpha.set(vertexBuffer, hasAlpha);\r\n    }\r\n\r\n    public getMesh(mesh: AbstractMesh): number | undefined {\r\n        return this._meshMap.get(mesh);\r\n    }\r\n\r\n    public setMesh(mesh: AbstractMesh, meshIndex: number): void {\r\n        this._meshMap.set(mesh, meshIndex);\r\n    }\r\n\r\n    public bindMorphDataToMesh(mesh: AbstractMesh, morphData: IMorphTargetData) {\r\n        const morphTargets = this._meshMorphTargetMap.get(mesh) || [];\r\n        this._meshMorphTargetMap.set(mesh, morphTargets);\r\n        if (morphTargets.indexOf(morphData) === -1) {\r\n            morphTargets.push(morphData);\r\n        }\r\n    }\r\n\r\n    public getMorphTargetsFromMesh(mesh: AbstractMesh): IMorphTargetData[] | undefined {\r\n        return this._meshMorphTargetMap.get(mesh);\r\n    }\r\n}\r\n\r\n/** @internal */\r\nexport class GLTFExporter {\r\n    public readonly _glTF: IGLTF = {\r\n        asset: { generator: `Babylon.js v${Engine.Version}`, version: \"2.0\" },\r\n    };\r\n\r\n    public readonly _animations: IAnimation[] = [];\r\n    public readonly _accessors: IAccessor[] = [];\r\n    public readonly _bufferViews: IBufferView[] = [];\r\n    public readonly _cameras: ICamera[] = [];\r\n    public readonly _images: IImage[] = [];\r\n    public readonly _materials: IMaterial[] = [];\r\n    public readonly _meshes: IMesh[] = [];\r\n    public readonly _nodes: INode[] = [];\r\n    public readonly _samplers: ISampler[] = [];\r\n    public readonly _scenes: IScene[] = [];\r\n    public readonly _skins: ISkin[] = [];\r\n    public readonly _textures: ITexture[] = [];\r\n\r\n    public readonly _babylonScene: Scene;\r\n    public readonly _imageData: { [fileName: string]: { data: ArrayBuffer; mimeType: ImageMimeType } } = {};\r\n\r\n    /**\r\n     * Baked animation sample rate\r\n     */\r\n    private _animationSampleRate: number;\r\n\r\n    private readonly _options: Required<IExportOptions>;\r\n\r\n    public _shouldUseGlb: boolean = false;\r\n\r\n    public readonly _materialExporter = new GLTFMaterialExporter(this);\r\n\r\n    private readonly _extensions: { [name: string]: IGLTFExporterExtensionV2 } = {};\r\n\r\n    public readonly _bufferManager = new BufferManager();\r\n\r\n    private readonly _shouldExportNodeMap = new Map<Node, boolean>();\r\n\r\n    // Babylon node -> glTF node index\r\n    private readonly _nodeMap = new Map<Node, number>();\r\n\r\n    // Babylon material -> glTF material index\r\n    public readonly _materialMap = new Map<Material, number>();\r\n    private readonly _camerasMap = new Map<Camera, ICamera>();\r\n    private readonly _nodesCameraMap = new Map<ICamera, INode[]>();\r\n    private readonly _skinMap = new Map<Skeleton, ISkin>();\r\n    private readonly _nodesSkinMap = new Map<ISkin, INode[]>();\r\n\r\n    // A material in this set requires UVs\r\n    public readonly _materialNeedsUVsSet = new Set<Material>();\r\n\r\n    private static readonly _ExtensionNames = new Array<string>();\r\n    private static readonly _ExtensionFactories: { [name: string]: (exporter: GLTFExporter) => IGLTFExporterExtensionV2 } = {};\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtension<T>(\r\n        node: T,\r\n        extensions: IGLTFExporterExtensionV2[],\r\n        index: number,\r\n        actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined\r\n    ): Promise<Nullable<T>> {\r\n        if (index >= extensions.length) {\r\n            return Promise.resolve(node);\r\n        }\r\n\r\n        const currentPromise = actionAsync(extensions[index], node);\r\n\r\n        if (!currentPromise) {\r\n            return this._ApplyExtension(node, extensions, index + 1, actionAsync);\r\n        }\r\n\r\n        // eslint-disable-next-line github/no-then\r\n        return currentPromise.then(async (newNode) => (newNode ? await this._ApplyExtension(newNode, extensions, index + 1, actionAsync) : null));\r\n    }\r\n\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/promise-function-async\r\n    private _ApplyExtensions<T>(node: T, actionAsync: (extension: IGLTFExporterExtensionV2, node: T) => Promise<Nullable<T>> | undefined): Promise<Nullable<T>> {\r\n        const extensions: IGLTFExporterExtensionV2[] = [];\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            extensions.push(this._extensions[name]);\r\n        }\r\n\r\n        return this._ApplyExtension(node, extensions, 0, actionAsync);\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPreExportTextureAsync(context: string, babylonTexture: Texture, mimeType: ImageMimeType): Promise<Nullable<BaseTexture>> {\r\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n        return this._ApplyExtensions(babylonTexture, (extension, node) => extension.preExportTextureAsync && extension.preExportTextureAsync(context, node, mimeType));\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return this._ApplyExtensions(\r\n            node,\r\n            // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n            (extension, node) => extension.postExportNodeAsync && extension.postExportNodeAsync(context, node, babylonNode, nodeMap, convertToRightHanded, this._bufferManager)\r\n        );\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax, @typescript-eslint/promise-function-async\r\n    public _extensionsPostExportMaterialAsync(context: string, material: IMaterial, babylonMaterial: Material): Promise<Nullable<IMaterial>> {\r\n        // eslint-disable-next-line @typescript-eslint/promise-function-async\r\n        return this._ApplyExtensions(material, (extension, node) => extension.postExportMaterialAsync && extension.postExportMaterialAsync(context, node, babylonMaterial));\r\n    }\r\n\r\n    public _extensionsPostExportMaterialAdditionalTextures(context: string, material: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const output: BaseTexture[] = [];\r\n\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMaterialAdditionalTextures) {\r\n                output.push(...extension.postExportMaterialAdditionalTextures(context, material, babylonMaterial));\r\n            }\r\n        }\r\n\r\n        return output;\r\n    }\r\n\r\n    public _extensionsPostExportTextures(context: string, textureInfo: ITextureInfo, babylonTexture: BaseTexture): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportTexture) {\r\n                extension.postExportTexture(context, textureInfo, babylonTexture);\r\n            }\r\n        }\r\n    }\r\n\r\n    public _extensionsPostExportMeshPrimitive(primitive: IMeshPrimitive): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.postExportMeshPrimitive) {\r\n                extension.postExportMeshPrimitive(primitive, this._bufferManager, this._accessors);\r\n            }\r\n        }\r\n    }\r\n\r\n    public async _extensionsPreGenerateBinaryAsync(): Promise<void> {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n\r\n            if (extension.preGenerateBinaryAsync) {\r\n                // eslint-disable-next-line no-await-in-loop\r\n                await extension.preGenerateBinaryAsync(this._bufferManager);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _forEachExtensions(action: (extension: IGLTFExporterExtensionV2) => void): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = this._extensions[name];\r\n            if (extension.enabled) {\r\n                action(extension);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _extensionsOnExporting(): void {\r\n        this._forEachExtensions((extension) => {\r\n            if (extension.wasUsed) {\r\n                this._glTF.extensionsUsed ||= [];\r\n                if (this._glTF.extensionsUsed.indexOf(extension.name) === -1) {\r\n                    this._glTF.extensionsUsed.push(extension.name);\r\n                }\r\n\r\n                if (extension.required) {\r\n                    this._glTF.extensionsRequired ||= [];\r\n                    if (this._glTF.extensionsRequired.indexOf(extension.name) === -1) {\r\n                        this._glTF.extensionsRequired.push(extension.name);\r\n                    }\r\n                }\r\n\r\n                this._glTF.extensions ||= {};\r\n                if (extension.onExporting) {\r\n                    extension.onExporting();\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    private _loadExtensions(): void {\r\n        for (const name of GLTFExporter._ExtensionNames) {\r\n            const extension = GLTFExporter._ExtensionFactories[name](this);\r\n            this._extensions[name] = extension;\r\n        }\r\n    }\r\n\r\n    public constructor(babylonScene: Nullable<Scene> = EngineStore.LastCreatedScene, options?: IExportOptions) {\r\n        if (!babylonScene) {\r\n            throw new Error(\"No scene available to export\");\r\n        }\r\n\r\n        this._babylonScene = babylonScene;\r\n\r\n        this._options = {\r\n            shouldExportNode: () => true,\r\n            shouldExportAnimation: () => true,\r\n            metadataSelector: (metadata) => metadata?.gltf?.extras,\r\n            animationSampleRate: 1 / 60,\r\n            exportWithoutWaitingForScene: false,\r\n            exportUnusedUVs: false,\r\n            removeNoopRootNodes: true,\r\n            includeCoordinateSystemConversionNodes: false,\r\n            meshCompressionMethod: \"None\",\r\n            ...options,\r\n        };\r\n\r\n        this._loadExtensions();\r\n    }\r\n\r\n    public dispose() {\r\n        for (const key in this._extensions) {\r\n            const extension = this._extensions[key];\r\n            extension.dispose();\r\n        }\r\n    }\r\n\r\n    public get options() {\r\n        return this._options;\r\n    }\r\n\r\n    public static RegisterExtension(name: string, factory: (exporter: GLTFExporter) => IGLTFExporterExtensionV2): void {\r\n        if (GLTFExporter.UnregisterExtension(name)) {\r\n            Tools.Warn(`Extension with the name ${name} already exists`);\r\n        }\r\n\r\n        GLTFExporter._ExtensionFactories[name] = factory;\r\n        GLTFExporter._ExtensionNames.push(name);\r\n    }\r\n\r\n    public static UnregisterExtension(name: string): boolean {\r\n        if (!GLTFExporter._ExtensionFactories[name]) {\r\n            return false;\r\n        }\r\n        delete GLTFExporter._ExtensionFactories[name];\r\n\r\n        const index = GLTFExporter._ExtensionNames.indexOf(name);\r\n        if (index !== -1) {\r\n            GLTFExporter._ExtensionNames.splice(index, 1);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    private _generateJSON(bufferByteLength: number, fileName?: string, prettyPrint?: boolean): string {\r\n        const buffer: IBuffer = { byteLength: bufferByteLength };\r\n\r\n        if (buffer.byteLength) {\r\n            this._glTF.buffers = [buffer];\r\n        }\r\n        if (this._nodes && this._nodes.length) {\r\n            this._glTF.nodes = this._nodes;\r\n        }\r\n        if (this._meshes && this._meshes.length) {\r\n            this._glTF.meshes = this._meshes;\r\n        }\r\n        if (this._scenes && this._scenes.length) {\r\n            this._glTF.scenes = this._scenes;\r\n            this._glTF.scene = 0;\r\n        }\r\n        if (this._cameras && this._cameras.length) {\r\n            this._glTF.cameras = this._cameras;\r\n        }\r\n        if (this._bufferViews && this._bufferViews.length) {\r\n            this._glTF.bufferViews = this._bufferViews;\r\n        }\r\n        if (this._accessors && this._accessors.length) {\r\n            this._glTF.accessors = this._accessors;\r\n        }\r\n        if (this._animations && this._animations.length) {\r\n            this._glTF.animations = this._animations;\r\n        }\r\n        if (this._materials && this._materials.length) {\r\n            this._glTF.materials = this._materials;\r\n        }\r\n        if (this._textures && this._textures.length) {\r\n            this._glTF.textures = this._textures;\r\n        }\r\n        if (this._samplers && this._samplers.length) {\r\n            this._glTF.samplers = this._samplers;\r\n        }\r\n        if (this._skins && this._skins.length) {\r\n            this._glTF.skins = this._skins;\r\n        }\r\n        if (this._images && this._images.length) {\r\n            this._glTF.images = this._images;\r\n        }\r\n\r\n        if (!this._shouldUseGlb) {\r\n            buffer.uri = fileName + \".bin\";\r\n        }\r\n\r\n        return prettyPrint ? JSON.stringify(this._glTF, null, 2) : JSON.stringify(this._glTF);\r\n    }\r\n\r\n    public async generateGLTFAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength, glTFPrefix, true);\r\n        const bin = new Blob([binaryBuffer], { type: \"application/octet-stream\" });\r\n\r\n        const glTFFileName = glTFPrefix + \".gltf\";\r\n        const glTFBinFile = glTFPrefix + \".bin\";\r\n\r\n        const container = new GLTFData();\r\n\r\n        container.files[glTFFileName] = jsonText;\r\n        container.files[glTFBinFile] = bin;\r\n\r\n        if (this._imageData) {\r\n            for (const image in this._imageData) {\r\n                container.files[image] = new Blob([this._imageData[image].data], { type: this._imageData[image].mimeType });\r\n            }\r\n        }\r\n\r\n        return container;\r\n    }\r\n\r\n    private async _generateBinaryAsync(): Promise<Uint8Array> {\r\n        await this._exportSceneAsync();\r\n        await this._extensionsPreGenerateBinaryAsync();\r\n        return this._bufferManager.generateBinary(this._bufferViews);\r\n    }\r\n\r\n    /**\r\n     * Pads the number to a multiple of 4\r\n     * @param num number to pad\r\n     * @returns padded number\r\n     */\r\n    private _getPadding(num: number): number {\r\n        const remainder = num % 4;\r\n        const padding = remainder === 0 ? remainder : 4 - remainder;\r\n\r\n        return padding;\r\n    }\r\n\r\n    public async generateGLBAsync(glTFPrefix: string): Promise<GLTFData> {\r\n        this._shouldUseGlb = true;\r\n        const binaryBuffer = await this._generateBinaryAsync();\r\n\r\n        this._extensionsOnExporting();\r\n        const jsonText = this._generateJSON(binaryBuffer.byteLength);\r\n        const glbFileName = glTFPrefix + \".glb\";\r\n        const headerLength = 12;\r\n        const chunkLengthPrefix = 8;\r\n        let jsonLength = jsonText.length;\r\n        let encodedJsonText;\r\n        // make use of TextEncoder when available\r\n        if (typeof TextEncoder !== \"undefined\") {\r\n            const encoder = new TextEncoder();\r\n            encodedJsonText = encoder.encode(jsonText);\r\n            jsonLength = encodedJsonText.length;\r\n        }\r\n        const jsonPadding = this._getPadding(jsonLength);\r\n        const binPadding = this._getPadding(binaryBuffer.byteLength);\r\n\r\n        const byteLength = headerLength + 2 * chunkLengthPrefix + jsonLength + jsonPadding + binaryBuffer.byteLength + binPadding;\r\n\r\n        // header\r\n        const headerBuffer = new ArrayBuffer(headerLength);\r\n        const headerBufferView = new DataView(headerBuffer);\r\n        headerBufferView.setUint32(0, 0x46546c67, true); //glTF\r\n        headerBufferView.setUint32(4, 2, true); // version\r\n        headerBufferView.setUint32(8, byteLength, true); // total bytes in file\r\n\r\n        // json chunk\r\n        const jsonChunkBuffer = new ArrayBuffer(chunkLengthPrefix + jsonLength + jsonPadding);\r\n        const jsonChunkBufferView = new DataView(jsonChunkBuffer);\r\n        jsonChunkBufferView.setUint32(0, jsonLength + jsonPadding, true);\r\n        jsonChunkBufferView.setUint32(4, 0x4e4f534a, true);\r\n\r\n        // json chunk bytes\r\n        const jsonData = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix);\r\n        // if TextEncoder was available, we can simply copy the encoded array\r\n        if (encodedJsonText) {\r\n            jsonData.set(encodedJsonText);\r\n        } else {\r\n            const blankCharCode = \"_\".charCodeAt(0);\r\n            for (let i = 0; i < jsonLength; ++i) {\r\n                const charCode = jsonText.charCodeAt(i);\r\n                // if the character doesn't fit into a single UTF-16 code unit, just put a blank character\r\n                if (charCode != jsonText.codePointAt(i)) {\r\n                    jsonData[i] = blankCharCode;\r\n                } else {\r\n                    jsonData[i] = charCode;\r\n                }\r\n            }\r\n        }\r\n\r\n        // json padding\r\n        const jsonPaddingView = new Uint8Array(jsonChunkBuffer, chunkLengthPrefix + jsonLength);\r\n        for (let i = 0; i < jsonPadding; ++i) {\r\n            jsonPaddingView[i] = 0x20;\r\n        }\r\n\r\n        // binary chunk\r\n        const binaryChunkBuffer = new ArrayBuffer(chunkLengthPrefix);\r\n        const binaryChunkBufferView = new DataView(binaryChunkBuffer);\r\n        binaryChunkBufferView.setUint32(0, binaryBuffer.byteLength + binPadding, true);\r\n        binaryChunkBufferView.setUint32(4, 0x004e4942, true);\r\n\r\n        // binary padding\r\n        const binPaddingBuffer = new ArrayBuffer(binPadding);\r\n        const binPaddingView = new Uint8Array(binPaddingBuffer);\r\n        for (let i = 0; i < binPadding; ++i) {\r\n            binPaddingView[i] = 0;\r\n        }\r\n\r\n        const glbData = [headerBuffer, jsonChunkBuffer, binaryChunkBuffer, binaryBuffer, binPaddingBuffer];\r\n        const glbFile = new Blob(glbData, { type: \"application/octet-stream\" });\r\n\r\n        const container = new GLTFData();\r\n        container.files[glbFileName] = glbFile;\r\n\r\n        return container;\r\n    }\r\n\r\n    private _setNodeTransformation(node: INode, babylonTransformNode: TransformNode, convertToRightHanded: boolean): void {\r\n        if (!babylonTransformNode.getPivotPoint().equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            Tools.Warn(\"Pivot points are not supported in the glTF serializer\");\r\n        }\r\n\r\n        if (!babylonTransformNode.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonTransformNode.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        if (!babylonTransformNode.scaling.equalsWithEpsilon(DefaultScale, Epsilon)) {\r\n            node.scale = babylonTransformNode.scaling.asArray();\r\n        }\r\n\r\n        const rotationQuaternion =\r\n            babylonTransformNode.rotationQuaternion ||\r\n            Quaternion.FromEulerAngles(babylonTransformNode.rotation.x, babylonTransformNode.rotation.y, babylonTransformNode.rotation.z);\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedRotation(rotationQuaternion);\r\n            }\r\n\r\n            node.rotation = rotationQuaternion.normalize().asArray();\r\n        }\r\n    }\r\n\r\n    private _setCameraTransformation(node: INode, babylonCamera: TargetCamera, convertToRightHanded: boolean): void {\r\n        if (!babylonCamera.position.equalsWithEpsilon(DefaultTranslation, Epsilon)) {\r\n            const translation = TmpVectors.Vector3[0].copyFrom(babylonCamera.position);\r\n            if (convertToRightHanded) {\r\n                ConvertToRightHandedPosition(translation);\r\n            }\r\n            node.translation = translation.asArray();\r\n        }\r\n\r\n        const rotationQuaternion = babylonCamera.rotationQuaternion || Quaternion.FromEulerAngles(babylonCamera.rotation.x, babylonCamera.rotation.y, babylonCamera.rotation.z);\r\n\r\n        if (convertToRightHanded) {\r\n            ConvertToRightHandedRotation(rotationQuaternion);\r\n        }\r\n\r\n        // Left-handed scenes have cameras that always face Z+ (opposite of glTF's Z-).\r\n        // Use scene coordinate system rather than convertToRightHanded, since some\r\n        // cameras may not need convertToRightHanded but still need correction to face Z-.\r\n        if (!this._babylonScene.useRightHandedSystem) {\r\n            Rotate180Y(rotationQuaternion);\r\n        }\r\n\r\n        if (!rotationQuaternion.equalsWithEpsilon(DefaultRotation, Epsilon)) {\r\n            node.rotation = rotationQuaternion.asArray();\r\n        }\r\n    }\r\n\r\n    // Export babylon cameras to glTF cameras\r\n    private _listAvailableCameras(): void {\r\n        for (const camera of this._babylonScene.cameras) {\r\n            const glTFCamera: ICamera = {\r\n                type: camera.mode === Camera.PERSPECTIVE_CAMERA ? CameraType.PERSPECTIVE : CameraType.ORTHOGRAPHIC,\r\n            };\r\n\r\n            if (camera.name) {\r\n                glTFCamera.name = camera.name;\r\n            }\r\n\r\n            if (glTFCamera.type === CameraType.PERSPECTIVE) {\r\n                glTFCamera.perspective = {\r\n                    aspectRatio: camera.getEngine().getAspectRatio(camera),\r\n                    yfov: camera.fovMode === Camera.FOVMODE_VERTICAL_FIXED ? camera.fov : camera.fov * camera.getEngine().getAspectRatio(camera),\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            } else if (glTFCamera.type === CameraType.ORTHOGRAPHIC) {\r\n                const halfWidth = camera.orthoLeft && camera.orthoRight ? 0.5 * (camera.orthoRight - camera.orthoLeft) : camera.getEngine().getRenderWidth() * 0.5;\r\n                const halfHeight = camera.orthoBottom && camera.orthoTop ? 0.5 * (camera.orthoTop - camera.orthoBottom) : camera.getEngine().getRenderHeight() * 0.5;\r\n                glTFCamera.orthographic = {\r\n                    xmag: halfWidth,\r\n                    ymag: halfHeight,\r\n                    znear: camera.minZ,\r\n                    zfar: camera.maxZ,\r\n                };\r\n            }\r\n            this._camerasMap.set(camera, glTFCamera);\r\n        }\r\n    }\r\n\r\n    // Cleanup unused cameras and assign index to nodes.\r\n    private _exportAndAssignCameras(): void {\r\n        const gltfCameras = Array.from(this._camerasMap.values());\r\n        for (const gltfCamera of gltfCameras) {\r\n            const usedNodes = this._nodesCameraMap.get(gltfCamera);\r\n            if (usedNodes !== undefined) {\r\n                this._cameras.push(gltfCamera);\r\n                for (const node of usedNodes) {\r\n                    node.camera = this._cameras.length - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Builds all skins in the skins array so nodes can reference it during node parsing.\r\n    private _listAvailableSkeletons(): void {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin: ISkin = { joints: [] };\r\n            this._skinMap.set(skeleton, skin);\r\n        }\r\n    }\r\n\r\n    private _exportAndAssignSkeletons() {\r\n        for (const skeleton of this._babylonScene.skeletons) {\r\n            if (skeleton.bones.length <= 0) {\r\n                continue;\r\n            }\r\n\r\n            const skin = this._skinMap.get(skeleton);\r\n\r\n            if (skin == undefined) {\r\n                continue;\r\n            }\r\n\r\n            const boneIndexMap: { [index: number]: Bone } = {};\r\n            const inverseBindMatrices: Matrix[] = [];\r\n\r\n            let maxBoneIndex = -1;\r\n            for (let i = 0; i < skeleton.bones.length; ++i) {\r\n                const bone = skeleton.bones[i];\r\n                const boneIndex = bone.getIndex() ?? i;\r\n                if (boneIndex !== -1) {\r\n                    boneIndexMap[boneIndex] = bone;\r\n                    if (boneIndex > maxBoneIndex) {\r\n                        maxBoneIndex = boneIndex;\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Set joints index to scene node.\r\n            for (let boneIndex = 0; boneIndex <= maxBoneIndex; ++boneIndex) {\r\n                const bone = boneIndexMap[boneIndex];\r\n                inverseBindMatrices.push(bone.getAbsoluteInverseBindMatrix());\r\n                const transformNode = bone.getTransformNode();\r\n\r\n                if (transformNode !== null) {\r\n                    const nodeID = this._nodeMap.get(transformNode);\r\n                    if (transformNode && nodeID !== null && nodeID !== undefined) {\r\n                        skin.joints.push(nodeID);\r\n                    } else {\r\n                        Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported\");\r\n                    }\r\n                } else {\r\n                    Tools.Warn(\"Exporting a bone without a linked transform node is currently unsupported\");\r\n                }\r\n            }\r\n\r\n            // Nodes that use this skin.\r\n            const skinedNodes = this._nodesSkinMap.get(skin);\r\n\r\n            // Only create skeleton if it has at least one joint and is used by a mesh.\r\n            if (skin.joints.length > 0 && skinedNodes !== undefined) {\r\n                // Put IBM data into TypedArraybuffer view\r\n                const byteLength = inverseBindMatrices.length * 64; // Always a 4 x 4 matrix of 32 bit float\r\n                const inverseBindMatricesData = new Float32Array(byteLength / 4);\r\n                inverseBindMatrices.forEach((mat: Matrix, index: number) => {\r\n                    inverseBindMatricesData.set(mat.m, index * 16);\r\n                });\r\n                // Create buffer view and accessor\r\n                const bufferView = this._bufferManager.createBufferView(inverseBindMatricesData);\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.MAT4, AccessorComponentType.FLOAT, inverseBindMatrices.length));\r\n                skin.inverseBindMatrices = this._accessors.length - 1;\r\n\r\n                this._skins.push(skin);\r\n                for (const skinedNode of skinedNodes) {\r\n                    skinedNode.skin = this._skins.length - 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private async _exportSceneAsync(): Promise<void> {\r\n        const scene: IScene = { nodes: [] };\r\n\r\n        // Scene metadata\r\n        if (this._babylonScene.metadata) {\r\n            const extras = this._options.metadataSelector(this._babylonScene.metadata);\r\n            if (extras) {\r\n                scene.extras = extras;\r\n            }\r\n        }\r\n\r\n        //  TODO:\r\n        //  deal with this from the loader:\r\n        //  babylonMaterial.invertNormalMapX = !this._babylonScene.useRightHandedSystem;\r\n        //  babylonMaterial.invertNormalMapY = this._babylonScene.useRightHandedSystem;\r\n\r\n        const rootNodesRH = new Array<Node>();\r\n        const rootNodesLH = new Array<Node>();\r\n        const rootNoopNodesRH = new Array<Node>();\r\n\r\n        for (const rootNode of this._babylonScene.rootNodes) {\r\n            if (this._options.removeNoopRootNodes && !this._options.includeCoordinateSystemConversionNodes && IsNoopNode(rootNode, this._babylonScene.useRightHandedSystem)) {\r\n                rootNoopNodesRH.push(...rootNode.getChildren());\r\n            } else if (this._babylonScene.useRightHandedSystem) {\r\n                rootNodesRH.push(rootNode);\r\n            } else {\r\n                rootNodesLH.push(rootNode);\r\n            }\r\n        }\r\n\r\n        this._listAvailableCameras();\r\n        this._listAvailableSkeletons();\r\n\r\n        const stateLH = new ExporterState(true, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesLH, stateLH)));\r\n        const stateRH = new ExporterState(false, false);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNodesRH, stateRH)));\r\n        const noopRH = new ExporterState(false, true);\r\n        scene.nodes.push(...(await this._exportNodesAsync(rootNoopNodesRH, noopRH)));\r\n\r\n        if (scene.nodes.length) {\r\n            this._scenes.push(scene);\r\n        }\r\n\r\n        this._exportAndAssignCameras();\r\n        this._exportAndAssignSkeletons();\r\n\r\n        if (this._babylonScene.animationGroups.length) {\r\n            _GLTFAnimation._CreateNodeAndMorphAnimationFromAnimationGroups(\r\n                this._babylonScene,\r\n                this._animations,\r\n                this._nodeMap,\r\n                this._bufferManager,\r\n                this._bufferViews,\r\n                this._accessors,\r\n                this._animationSampleRate,\r\n                stateLH.getNodesSet(),\r\n                this._options.shouldExportAnimation\r\n            );\r\n        }\r\n    }\r\n\r\n    private _shouldExportNode(babylonNode: Node): boolean {\r\n        let result = this._shouldExportNodeMap.get(babylonNode);\r\n\r\n        if (result === undefined) {\r\n            result = this._options.shouldExportNode(babylonNode);\r\n            this._shouldExportNodeMap.set(babylonNode, result);\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    private async _exportNodesAsync(babylonRootNodes: Node[], state: ExporterState): Promise<number[]> {\r\n        const nodes = new Array<number>();\r\n\r\n        this._exportBuffers(babylonRootNodes, state);\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonNode, nodes, state);\r\n        }\r\n\r\n        return nodes;\r\n    }\r\n\r\n    private _collectBuffers(\r\n        babylonNode: Node,\r\n        bufferToVertexBuffersMap: Map<Buffer, VertexBuffer[]>,\r\n        vertexBufferToMeshesMap: Map<VertexBuffer, AbstractMesh[]>,\r\n        morphTargetsToMeshesMap: Map<MorphTarget, AbstractMesh[]>,\r\n        state: ExporterState\r\n    ): void {\r\n        if (this._shouldExportNode(babylonNode) && babylonNode instanceof AbstractMesh && babylonNode.geometry) {\r\n            const vertexBuffers = babylonNode.geometry.getVertexBuffers();\r\n            if (vertexBuffers) {\r\n                for (const kind in vertexBuffers) {\r\n                    if (!IsStandardVertexAttribute(kind)) {\r\n                        continue;\r\n                    }\r\n                    const vertexBuffer = vertexBuffers[kind];\r\n                    state.setHasVertexColorAlpha(vertexBuffer, babylonNode.hasVertexAlpha);\r\n                    const buffer = vertexBuffer._buffer;\r\n                    const vertexBufferArray = bufferToVertexBuffersMap.get(buffer) || [];\r\n                    bufferToVertexBuffersMap.set(buffer, vertexBufferArray);\r\n                    if (vertexBufferArray.indexOf(vertexBuffer) === -1) {\r\n                        vertexBufferArray.push(vertexBuffer);\r\n                    }\r\n\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer) || [];\r\n                    vertexBufferToMeshesMap.set(vertexBuffer, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n\r\n            const morphTargetManager = babylonNode.morphTargetManager;\r\n\r\n            if (morphTargetManager) {\r\n                for (let morphIndex = 0; morphIndex < morphTargetManager.numTargets; morphIndex++) {\r\n                    const morphTarget = morphTargetManager.getTarget(morphIndex);\r\n\r\n                    const meshes = morphTargetsToMeshesMap.get(morphTarget) || [];\r\n                    morphTargetsToMeshesMap.set(morphTarget, meshes);\r\n                    if (meshes.indexOf(babylonNode) === -1) {\r\n                        meshes.push(babylonNode);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            this._collectBuffers(babylonChildNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsToMeshesMap, state);\r\n        }\r\n    }\r\n\r\n    private _exportBuffers(babylonRootNodes: Node[], state: ExporterState): void {\r\n        const bufferToVertexBuffersMap = new Map<Buffer, VertexBuffer[]>();\r\n        const vertexBufferToMeshesMap = new Map<VertexBuffer, AbstractMesh[]>();\r\n        const morphTargetsMeshesMap = new Map<MorphTarget, AbstractMesh[]>();\r\n\r\n        for (const babylonNode of babylonRootNodes) {\r\n            this._collectBuffers(babylonNode, bufferToVertexBuffersMap, vertexBufferToMeshesMap, morphTargetsMeshesMap, state);\r\n        }\r\n\r\n        const buffers = Array.from(bufferToVertexBuffersMap.keys());\r\n\r\n        for (const buffer of buffers) {\r\n            const data = buffer.getData();\r\n            if (!data) {\r\n                throw new Error(\"Buffer data is not available\");\r\n            }\r\n\r\n            const vertexBuffers = bufferToVertexBuffersMap.get(buffer);\r\n\r\n            if (!vertexBuffers) {\r\n                continue;\r\n            }\r\n\r\n            const byteStride = vertexBuffers[0].byteStride;\r\n            if (vertexBuffers.some((vertexBuffer) => vertexBuffer.byteStride !== byteStride)) {\r\n                throw new Error(\"Vertex buffers pointing to the same buffer must have the same byte stride\");\r\n            }\r\n\r\n            const bytes = DataArrayToUint8Array(data).slice();\r\n\r\n            // Apply normalizations and color corrections to buffer data in-place.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                switch (kind) {\r\n                    // Normalize normals and tangents.\r\n                    case VertexBuffer.NormalKind:\r\n                    case VertexBuffer.TangentKind: {\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            const length = Math.sqrt(values[0] * values[0] + values[1] * values[1] + values[2] * values[2]);\r\n                            if (length > 0) {\r\n                                const invLength = 1 / length;\r\n                                values[0] *= invLength;\r\n                                values[1] *= invLength;\r\n                                values[2] *= invLength;\r\n                            }\r\n                        });\r\n                        break;\r\n                    }\r\n                    // Convert StandardMaterial vertex colors from gamma to linear space.\r\n                    case VertexBuffer.ColorKind: {\r\n                        const stdMaterialCount = meshes.filter((mesh) => mesh.material instanceof StandardMaterial || mesh.material == null).length;\r\n                        if (stdMaterialCount == 0) {\r\n                            break; // Buffer not used by StandardMaterials, so no conversion needed.\r\n                        }\r\n                        // TODO: Implement this case.\r\n                        if (stdMaterialCount != meshes.length) {\r\n                            Logger.Warn(\"Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.\");\r\n                            break;\r\n                        }\r\n                        if (type == VertexBuffer.UNSIGNED_BYTE) {\r\n                            Logger.Warn(\"Converting uint8 vertex colors to linear space. Results may look incorrect.\");\r\n                        }\r\n\r\n                        const vertexData3 = new Color3();\r\n                        const vertexData4 = new Color4();\r\n                        const useExactSrgbConversions = this._babylonScene.getEngine().useExactSrgbConversions;\r\n\r\n                        EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                            // Using separate Color3 and Color4 objects to ensure the right functions are called.\r\n                            if (values.length === 3) {\r\n                                vertexData3.fromArray(values, 0);\r\n                                vertexData3.toLinearSpaceToRef(vertexData3, useExactSrgbConversions);\r\n                                vertexData3.toArray(values, 0);\r\n                            } else {\r\n                                vertexData4.fromArray(values, 0);\r\n                                vertexData4.toLinearSpaceToRef(vertexData4, useExactSrgbConversions);\r\n                                vertexData4.toArray(values, 0);\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n\r\n            // Perform coordinate conversions, if needed, to buffer data in-place (only for positions, normals and tangents).\r\n            if (state.convertToRightHanded) {\r\n                for (const vertexBuffer of vertexBuffers) {\r\n                    const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                    const { byteOffset, byteStride, componentCount, type, count, normalized, kind } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n\r\n                    switch (kind) {\r\n                        case VertexBuffer.PositionKind:\r\n                        case VertexBuffer.NormalKind:\r\n                        case VertexBuffer.TangentKind: {\r\n                            EnumerateFloatValues(bytes, byteOffset, byteStride, componentCount, type, count, normalized, (values) => {\r\n                                values[0] = -values[0];\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // Save converted bytes for min/max computation.\r\n                state.convertedToRightHandedBuffers.set(buffer, bytes);\r\n            }\r\n\r\n            // Create buffer view, but defer accessor creation for later. Instead, track it via ExporterState.\r\n            const bufferView = this._bufferManager.createBufferView(bytes, byteStride);\r\n            state.setVertexBufferView(buffer, bufferView);\r\n\r\n            const floatMatricesIndices = new Map<VertexBuffer, FloatArray>();\r\n\r\n            // If buffers are of type MatricesIndicesKind and have float values, we need to create a new buffer instead.\r\n            for (const vertexBuffer of vertexBuffers) {\r\n                const meshes = vertexBufferToMeshesMap.get(vertexBuffer)!;\r\n                const { kind, totalVertices } = GetVertexBufferInfo(vertexBuffer, meshes);\r\n                switch (kind) {\r\n                    case VertexBuffer.MatricesIndicesKind:\r\n                    case VertexBuffer.MatricesIndicesExtraKind: {\r\n                        if (vertexBuffer.type == VertexBuffer.FLOAT) {\r\n                            const floatData = vertexBuffer.getFloatData(totalVertices);\r\n                            if (floatData !== null) {\r\n                                floatMatricesIndices.set(vertexBuffer, floatData);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (floatMatricesIndices.size !== 0) {\r\n                Logger.Warn(\r\n                    `Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.`\r\n                );\r\n            }\r\n\r\n            const floatArrayVertexBuffers = Array.from(floatMatricesIndices.keys());\r\n\r\n            for (const vertexBuffer of floatArrayVertexBuffers) {\r\n                const array = floatMatricesIndices.get(vertexBuffer);\r\n\r\n                if (!array) {\r\n                    continue;\r\n                }\r\n\r\n                const is16Bit = FloatsNeed16BitInteger(array);\r\n                const newArray = new (is16Bit ? Uint16Array : Uint8Array)(array.length);\r\n                for (let index = 0; index < array.length; index++) {\r\n                    newArray[index] = array[index];\r\n                }\r\n                const bufferView = this._bufferManager.createBufferView(newArray, 4 * (is16Bit ? 2 : 1));\r\n                state.setRemappedBufferView(buffer, vertexBuffer, bufferView);\r\n            }\r\n        }\r\n\r\n        // Build morph targets buffers\r\n        const morphTargets = Array.from(morphTargetsMeshesMap.keys());\r\n\r\n        for (const morphTarget of morphTargets) {\r\n            const meshes = morphTargetsMeshesMap.get(morphTarget);\r\n\r\n            if (!meshes) {\r\n                continue;\r\n            }\r\n\r\n            const glTFMorphTarget = BuildMorphTargetBuffers(morphTarget, meshes[0], this._bufferManager, this._bufferViews, this._accessors, state.convertToRightHanded);\r\n\r\n            for (const mesh of meshes) {\r\n                state.bindMorphDataToMesh(mesh, glTFMorphTarget);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Processes a node to be exported to the glTF file\r\n     * @returns A promise that resolves once the node has been exported\r\n     * @internal\r\n     */\r\n    private async _exportNodeAsync(babylonNode: Node, parentNodeChildren: Array<number>, state: ExporterState): Promise<void> {\r\n        let nodeIndex = this._nodeMap.get(babylonNode);\r\n        if (nodeIndex !== undefined) {\r\n            if (!parentNodeChildren.includes(nodeIndex)) {\r\n                parentNodeChildren.push(nodeIndex);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const node = await this._createNodeAsync(babylonNode, state);\r\n\r\n        if (node) {\r\n            nodeIndex = this._nodes.length;\r\n            this._nodes.push(node);\r\n            this._nodeMap.set(babylonNode, nodeIndex);\r\n            state.pushExportedNode(babylonNode);\r\n            parentNodeChildren.push(nodeIndex);\r\n\r\n            // Process node's animations once the node has been added to nodeMap (TODO: This should be refactored)\r\n            const runtimeGLTFAnimation: IAnimation = {\r\n                name: \"runtime animations\",\r\n                channels: [],\r\n                samplers: [],\r\n            };\r\n            const idleGLTFAnimations: IAnimation[] = [];\r\n\r\n            if (!this._babylonScene.animationGroups.length) {\r\n                _GLTFAnimation._CreateMorphTargetAnimationFromMorphTargetAnimations(\r\n                    babylonNode,\r\n                    runtimeGLTFAnimation,\r\n                    idleGLTFAnimations,\r\n                    this._nodeMap,\r\n                    this._nodes,\r\n                    this._bufferManager,\r\n                    this._bufferViews,\r\n                    this._accessors,\r\n                    this._animationSampleRate,\r\n                    state.convertToRightHanded,\r\n                    this._options.shouldExportAnimation\r\n                );\r\n                if (babylonNode.animations.length) {\r\n                    _GLTFAnimation._CreateNodeAnimationFromNodeAnimations(\r\n                        babylonNode,\r\n                        runtimeGLTFAnimation,\r\n                        idleGLTFAnimations,\r\n                        this._nodeMap,\r\n                        this._nodes,\r\n                        this._bufferManager,\r\n                        this._bufferViews,\r\n                        this._accessors,\r\n                        this._animationSampleRate,\r\n                        state.convertToRightHanded,\r\n                        this._options.shouldExportAnimation\r\n                    );\r\n                }\r\n            }\r\n\r\n            if (runtimeGLTFAnimation.channels.length && runtimeGLTFAnimation.samplers.length) {\r\n                this._animations.push(runtimeGLTFAnimation);\r\n            }\r\n            idleGLTFAnimations.forEach((idleGLTFAnimation) => {\r\n                if (idleGLTFAnimation.channels.length && idleGLTFAnimation.samplers.length) {\r\n                    this._animations.push(idleGLTFAnimation);\r\n                }\r\n            });\r\n        }\r\n\r\n        // Begin processing child nodes once parent has been added to the node list\r\n        const children = node ? [] : parentNodeChildren;\r\n        for (const babylonChildNode of babylonNode.getChildren()) {\r\n            // eslint-disable-next-line no-await-in-loop\r\n            await this._exportNodeAsync(babylonChildNode, children, state);\r\n        }\r\n\r\n        if (node && children.length) {\r\n            node.children = children;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Creates a glTF node from a Babylon.js node. If skipped, returns null.\r\n     * @internal\r\n     */\r\n    private async _createNodeAsync(babylonNode: Node, state: ExporterState): Promise<Nullable<INode>> {\r\n        if (!this._shouldExportNode(babylonNode)) {\r\n            return null;\r\n        }\r\n\r\n        const node: INode = {};\r\n\r\n        if (babylonNode.name) {\r\n            node.name = babylonNode.name;\r\n        }\r\n\r\n        // Node metadata\r\n        if (babylonNode.metadata) {\r\n            const extras = this._options.metadataSelector(babylonNode.metadata);\r\n            if (extras) {\r\n                node.extras = extras;\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TransformNode) {\r\n            this._setNodeTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n            if (babylonNode instanceof AbstractMesh) {\r\n                const babylonMesh = babylonNode instanceof InstancedMesh ? babylonNode.sourceMesh : (babylonNode as Mesh);\r\n                if (babylonMesh.subMeshes && babylonMesh.subMeshes.length > 0) {\r\n                    node.mesh = await this._exportMeshAsync(babylonMesh, state);\r\n                }\r\n\r\n                if (babylonNode.skeleton) {\r\n                    const skin = this._skinMap.get(babylonNode.skeleton);\r\n\r\n                    if (skin !== undefined) {\r\n                        if (this._nodesSkinMap.get(skin) === undefined) {\r\n                            this._nodesSkinMap.set(skin, []);\r\n                        }\r\n\r\n                        this._nodesSkinMap.get(skin)?.push(node);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (babylonNode instanceof TargetCamera) {\r\n            const gltfCamera = this._camerasMap.get(babylonNode);\r\n\r\n            if (gltfCamera) {\r\n                if (this._nodesCameraMap.get(gltfCamera) === undefined) {\r\n                    this._nodesCameraMap.set(gltfCamera, []);\r\n                }\r\n\r\n                this._setCameraTransformation(node, babylonNode, state.convertToRightHanded);\r\n\r\n                // If a parent node exists and can be collapsed, merge their transformations and mark the parent as the camera-containing node.\r\n                const parentBabylonNode = babylonNode.parent;\r\n                if (parentBabylonNode !== null && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                    const parentNodeIndex = this._nodeMap.get(parentBabylonNode);\r\n                    if (parentNodeIndex !== undefined) {\r\n                        const parentNode = this._nodes[parentNodeIndex];\r\n                        CollapseChildIntoParent(node, parentNode);\r\n                        this._nodesCameraMap.get(gltfCamera)?.push(parentNode);\r\n                        return null; // Skip exporting the original child node\r\n                    }\r\n                }\r\n\r\n                this._nodesCameraMap.get(gltfCamera)?.push(node);\r\n            }\r\n        }\r\n\r\n        // Apply extensions to the node. If this resolves to null, it means we should skip exporting this node\r\n        const processedNode = await this._extensionsPostExportNodeAsync(\"exportNodeAsync\", node, babylonNode, this._nodeMap, state.convertToRightHanded);\r\n        if (!processedNode) {\r\n            Logger.Warn(`Not exporting node ${babylonNode.name}`);\r\n            return null;\r\n        }\r\n\r\n        return node;\r\n    }\r\n\r\n    private _exportIndices(\r\n        indices: Nullable<IndicesArray>,\r\n        is32Bits: boolean,\r\n        start: number,\r\n        count: number,\r\n        offset: number,\r\n        fillMode: number,\r\n        sideOrientation: number,\r\n        state: ExporterState,\r\n        primitive: IMeshPrimitive\r\n    ): void {\r\n        let indicesToExport = indices;\r\n\r\n        primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n        // Flip if triangle winding order is not CCW as glTF is always CCW.\r\n        const invertedMaterial = sideOrientation !== Material.CounterClockWiseSideOrientation;\r\n\r\n        const flipWhenInvertedMaterial = !state.wasAddedByNoopNode && invertedMaterial;\r\n\r\n        const flip = IsTriangleFillMode(fillMode) && flipWhenInvertedMaterial;\r\n\r\n        if (flip) {\r\n            if (fillMode === Material.TriangleStripDrawMode || fillMode === Material.TriangleFanDrawMode) {\r\n                throw new Error(\"Triangle strip/fan fill mode is not implemented\");\r\n            }\r\n\r\n            primitive.mode = GetPrimitiveMode(fillMode);\r\n\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n\r\n            if (indices) {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = indices[start + i] + offset;\r\n                    newIndices[i + 1] = indices[start + i + 2] + offset;\r\n                    newIndices[i + 2] = indices[start + i + 1] + offset;\r\n                }\r\n            } else {\r\n                for (let i = 0; i + 2 < count; i += 3) {\r\n                    newIndices[i] = i;\r\n                    newIndices[i + 1] = i + 2;\r\n                    newIndices[i + 2] = i + 1;\r\n                }\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        } else if (indices && offset !== 0) {\r\n            const newIndices = is32Bits ? new Uint32Array(count) : new Uint16Array(count);\r\n            for (let i = 0; i < count; i++) {\r\n                newIndices[i] = indices[start + i] + offset;\r\n            }\r\n\r\n            indicesToExport = newIndices;\r\n        }\r\n\r\n        if (indicesToExport) {\r\n            let accessorIndex = state.getIndicesAccessor(indices, start, count, offset, flip);\r\n            if (accessorIndex === undefined) {\r\n                const bytes = IndicesArrayToTypedArray(indicesToExport, 0, count, is32Bits);\r\n                const bufferView = this._bufferManager.createBufferView(bytes);\r\n\r\n                const componentType = is32Bits ? AccessorComponentType.UNSIGNED_INT : AccessorComponentType.UNSIGNED_SHORT;\r\n                this._accessors.push(this._bufferManager.createAccessor(bufferView, AccessorType.SCALAR, componentType, count, 0));\r\n                accessorIndex = this._accessors.length - 1;\r\n                state.setIndicesAccessor(indices, start, count, offset, flip, accessorIndex);\r\n            }\r\n\r\n            primitive.indices = accessorIndex;\r\n        }\r\n    }\r\n\r\n    private _exportVertexBuffer(vertexBuffer: VertexBuffer, babylonMaterial: Material, start: number, count: number, state: ExporterState, primitive: IMeshPrimitive): void {\r\n        const kind = vertexBuffer.getKind();\r\n\r\n        if (!IsStandardVertexAttribute(kind)) {\r\n            return;\r\n        }\r\n\r\n        if (kind.startsWith(\"uv\") && !this._options.exportUnusedUVs) {\r\n            if (!babylonMaterial || !this._materialNeedsUVsSet.has(babylonMaterial)) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        let accessorIndex = state.getVertexAccessor(vertexBuffer, start, count);\r\n\r\n        if (accessorIndex === undefined) {\r\n            // Get min/max from converted or original data.\r\n            const data = state.convertedToRightHandedBuffers.get(vertexBuffer._buffer) || vertexBuffer._buffer.getData()!;\r\n            const minMax = kind === VertexBuffer.PositionKind ? GetMinMax(data, vertexBuffer, start, count) : undefined;\r\n\r\n            // For the remapped buffer views we created for float matrices indices, make sure to use their updated information.\r\n            const isFloatMatricesIndices =\r\n                (kind === VertexBuffer.MatricesIndicesKind || kind === VertexBuffer.MatricesIndicesExtraKind) && vertexBuffer.type === VertexBuffer.FLOAT;\r\n\r\n            const vertexBufferType = isFloatMatricesIndices ? VertexBuffer.UNSIGNED_BYTE : vertexBuffer.type;\r\n            const vertexBufferNormalized = isFloatMatricesIndices ? undefined : vertexBuffer.normalized;\r\n            const bufferView = isFloatMatricesIndices ? state.getRemappedBufferView(vertexBuffer._buffer, vertexBuffer)! : state.getVertexBufferView(vertexBuffer._buffer)!;\r\n\r\n            const byteOffset = vertexBuffer.byteOffset + start * vertexBuffer.byteStride;\r\n            this._accessors.push(\r\n                this._bufferManager.createAccessor(\r\n                    bufferView,\r\n                    GetAccessorType(kind, state.hasVertexColorAlpha(vertexBuffer)),\r\n                    vertexBufferType,\r\n                    count,\r\n                    byteOffset,\r\n                    minMax,\r\n                    vertexBufferNormalized // TODO: Find other places where this is needed.\r\n                )\r\n            );\r\n            accessorIndex = this._accessors.length - 1;\r\n            state.setVertexAccessor(vertexBuffer, start, count, accessorIndex);\r\n        }\r\n\r\n        primitive.attributes[GetAttributeType(kind)] = accessorIndex;\r\n    }\r\n\r\n    private async _exportMaterialAsync(babylonMaterial: Material, vertexBuffers: { [kind: string]: VertexBuffer }, subMesh: SubMesh, primitive: IMeshPrimitive): Promise<void> {\r\n        let materialIndex = this._materialMap.get(babylonMaterial);\r\n        if (materialIndex === undefined) {\r\n            const hasUVs = vertexBuffers && Object.keys(vertexBuffers).some((kind) => kind.startsWith(\"uv\"));\r\n            babylonMaterial = babylonMaterial instanceof MultiMaterial ? babylonMaterial.subMaterials[subMesh.materialIndex]! : babylonMaterial;\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                materialIndex = await this._materialExporter.exportPBRMaterialAsync(babylonMaterial, ImageMimeType.PNG, hasUVs);\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                materialIndex = await this._materialExporter.exportStandardMaterialAsync(babylonMaterial, ImageMimeType.PNG, hasUVs);\r\n            } else {\r\n                Logger.Warn(`Unsupported material '${babylonMaterial.name}' with type ${babylonMaterial.getClassName()}`);\r\n                return;\r\n            }\r\n\r\n            this._materialMap.set(babylonMaterial, materialIndex);\r\n        }\r\n\r\n        primitive.material = materialIndex;\r\n    }\r\n\r\n    private async _exportMeshAsync(babylonMesh: Mesh, state: ExporterState): Promise<number> {\r\n        let meshIndex = state.getMesh(babylonMesh);\r\n        if (meshIndex !== undefined) {\r\n            return meshIndex;\r\n        }\r\n\r\n        const mesh: IMesh = { primitives: [] };\r\n        meshIndex = this._meshes.length;\r\n        this._meshes.push(mesh);\r\n        state.setMesh(babylonMesh, meshIndex);\r\n\r\n        const indices = babylonMesh.isUnIndexed ? null : babylonMesh.getIndices();\r\n        const vertexBuffers = babylonMesh.geometry?.getVertexBuffers();\r\n        const morphTargets = state.getMorphTargetsFromMesh(babylonMesh);\r\n\r\n        const isLinesMesh = babylonMesh instanceof LinesMesh;\r\n        const isGreasedLineMesh = babylonMesh instanceof GreasedLineBaseMesh;\r\n\r\n        const subMeshes = babylonMesh.subMeshes;\r\n        if (vertexBuffers && subMeshes && subMeshes.length > 0) {\r\n            for (const subMesh of subMeshes) {\r\n                const primitive: IMeshPrimitive = { attributes: {} };\r\n\r\n                const babylonMaterial = subMesh.getMaterial() || this._babylonScene.defaultMaterial;\r\n\r\n                if (isGreasedLineMesh) {\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    const colorWhite = Color3.White();\r\n                    const alpha = babylonLinesMesh.material?.alpha ?? 1;\r\n                    const color = babylonLinesMesh.greasedLineMaterial?.color ?? colorWhite;\r\n                    if (!color.equalsWithEpsilon(colorWhite, Epsilon) || alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...color.asArray(), alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else if (isLinesMesh) {\r\n                    // Special case for LinesMesh\r\n                    const material: IMaterial = {\r\n                        name: babylonMaterial.name,\r\n                    };\r\n\r\n                    const babylonLinesMesh = babylonMesh;\r\n\r\n                    if (!babylonLinesMesh.color.equalsWithEpsilon(Color3.White(), Epsilon) || babylonLinesMesh.alpha < 1) {\r\n                        material.pbrMetallicRoughness = {\r\n                            baseColorFactor: [...babylonLinesMesh.color.asArray(), babylonLinesMesh.alpha],\r\n                        };\r\n                    }\r\n\r\n                    this._materials.push(material);\r\n                    primitive.material = this._materials.length - 1;\r\n                } else {\r\n                    // Material\r\n                    // eslint-disable-next-line no-await-in-loop\r\n                    await this._exportMaterialAsync(babylonMaterial, vertexBuffers, subMesh, primitive);\r\n                }\r\n\r\n                // Index buffer\r\n                const fillMode = isLinesMesh || isGreasedLineMesh ? Material.LineListDrawMode : (babylonMesh.overrideRenderingFillMode ?? babylonMaterial.fillMode);\r\n\r\n                const sideOrientation = babylonMaterial._getEffectiveOrientation(babylonMesh);\r\n\r\n                this._exportIndices(\r\n                    indices,\r\n                    indices ? AreIndices32Bits(indices, subMesh.indexCount, subMesh.indexStart, subMesh.verticesStart) : subMesh.verticesCount > 65535,\r\n                    indices ? subMesh.indexStart : subMesh.verticesStart,\r\n                    indices ? subMesh.indexCount : subMesh.verticesCount,\r\n                    -subMesh.verticesStart,\r\n                    fillMode,\r\n                    sideOrientation,\r\n                    state,\r\n                    primitive\r\n                );\r\n\r\n                // Vertex buffers\r\n                for (const vertexBuffer of Object.values(vertexBuffers)) {\r\n                    this._exportVertexBuffer(vertexBuffer, babylonMaterial, subMesh.verticesStart, subMesh.verticesCount, state, primitive);\r\n                }\r\n\r\n                if (morphTargets) {\r\n                    primitive.targets = [];\r\n                    for (const gltfMorphTarget of morphTargets) {\r\n                        primitive.targets.push(gltfMorphTarget.attributes);\r\n                    }\r\n                }\r\n\r\n                mesh.primitives.push(primitive);\r\n                this._extensionsPostExportMeshPrimitive(primitive);\r\n            }\r\n        }\r\n\r\n        if (morphTargets) {\r\n            mesh.weights = [];\r\n\r\n            if (!mesh.extras) {\r\n                mesh.extras = {};\r\n            }\r\n            mesh.extras.targetNames = [];\r\n\r\n            for (const gltfMorphTarget of morphTargets) {\r\n                mesh.weights.push(gltfMorphTarget.influence);\r\n                mesh.extras.targetNames.push(gltfMorphTarget.name);\r\n            }\r\n        }\r\n\r\n        return meshIndex;\r\n    }\r\n}\r\n","import type { Node } from \"core/node\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Animation } from \"core/Animations/animation\";\r\nimport type { GLTFData } from \"./glTFData\";\r\nimport { GLTFExporter } from \"./glTFExporter\";\r\n\r\n/**\r\n * Mesh compression methods.\r\n */\r\nexport type MeshCompressionMethod = \"None\" | \"Draco\";\r\n\r\n/**\r\n * Holds a collection of exporter options and parameters\r\n */\r\nexport interface IExportOptions {\r\n    /**\r\n     * Function which indicates whether a babylon node should be exported or not\r\n     * @param node source Babylon node. It is used to check whether it should be exported to glTF or not\r\n     * @returns boolean, which indicates whether the node should be exported (true) or not (false)\r\n     */\r\n    shouldExportNode?(node: Node): boolean;\r\n\r\n    /**\r\n     * Function which indicates whether an animation on the scene should be exported or not\r\n     * @param animation source animation\r\n     * @returns boolean, which indicates whether the animation should be exported (true) or not (false)\r\n     */\r\n    shouldExportAnimation?(animation: Animation): boolean;\r\n\r\n    /**\r\n     * Function to extract the part of the scene or node's `metadata` that will populate the corresponding\r\n     * glTF object's `extras` field. If not defined, `node.metadata.gltf.extras` will be used.\r\n     * @param metadata source metadata to read from\r\n     * @returns the data to store into the glTF extras field\r\n     */\r\n    metadataSelector?(metadata: any): any;\r\n\r\n    /**\r\n     * The sample rate to bake animation curves. Defaults to 1 / 60.\r\n     */\r\n    animationSampleRate?: number;\r\n\r\n    /**\r\n     * Begin serialization without waiting for the scene to be ready. Defaults to false.\r\n     */\r\n    exportWithoutWaitingForScene?: boolean;\r\n\r\n    /**\r\n     * Indicates if unused vertex uv attributes should be included in export. Defaults to false.\r\n     */\r\n    exportUnusedUVs?: boolean;\r\n\r\n    /**\r\n     * Remove no-op root nodes when possible. Defaults to true.\r\n     */\r\n    removeNoopRootNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates if coordinate system swapping root nodes should be included in export. Defaults to false.\r\n     * @deprecated Please use removeNoopRootNodes instead\r\n     */\r\n    includeCoordinateSystemConversionNodes?: boolean;\r\n\r\n    /**\r\n     * Indicates what compression method to apply to mesh data.\r\n     */\r\n    meshCompressionMethod?: MeshCompressionMethod;\r\n}\r\n\r\n/**\r\n * Class for generating glTF data from a Babylon scene.\r\n */\r\nexport class GLTF2Export {\r\n    /**\r\n     * Exports the scene to .gltf file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .gltf file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLTFAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLTFAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Exports the scene to .glb file format\r\n     * @param scene Babylon scene\r\n     * @param fileName Name to use for the .glb file\r\n     * @param options Exporter options\r\n     * @returns Returns the exported data\r\n     */\r\n    public static async GLBAsync(scene: Scene, fileName: string, options?: IExportOptions): Promise<GLTFData> {\r\n        if (!options || !options.exportWithoutWaitingForScene) {\r\n            await scene.whenReadyAsync();\r\n        }\r\n\r\n        const exporter = new GLTFExporter(scene, options);\r\n        const data = await exporter.generateGLBAsync(fileName.replace(/\\.[^/.]+$/, \"\"));\r\n        exporter.dispose();\r\n\r\n        return data;\r\n    }\r\n}\r\n","import type { INode, IEXTMeshGpuInstancing } from \"babylonjs-gltf2interface\";\r\nimport { AccessorType, AccessorComponentType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport type { BufferManager } from \"../bufferManager\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Nullable } from \"core/types\";\r\nimport type { Node } from \"core/node\";\r\nimport { Mesh } from \"core/Meshes/mesh\";\r\nimport \"core/Meshes/thinInstanceMesh\";\r\nimport { TmpVectors, Quaternion, Vector3 } from \"core/Maths/math.vector\";\r\nimport { ConvertToRightHandedPosition, ConvertToRightHandedRotation } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"EXT_mesh_gpu_instancing\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_mesh_gpu_instancing implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After node is exported\r\n     * @param context the GLTF context when loading the asset\r\n     * @param node the node exported\r\n     * @param babylonNode the corresponding babylon node\r\n     * @param nodeMap map from babylon node id to node index\r\n     * @param convertToRightHanded true if we need to convert data from left hand to right hand system.\r\n     * @param bufferManager buffer manager\r\n     * @returns nullable promise, resolves with the node\r\n     */\r\n    public async postExportNodeAsync(\r\n        context: string,\r\n        node: Nullable<INode>,\r\n        babylonNode: Node,\r\n        nodeMap: Map<Node, number>,\r\n        convertToRightHanded: boolean,\r\n        bufferManager: BufferManager\r\n    ): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (node && babylonNode instanceof Mesh) {\r\n                if (babylonNode.hasThinInstances && this._exporter) {\r\n                    this._wasUsed = true;\r\n\r\n                    const noTranslation = Vector3.Zero();\r\n                    const noRotation = Quaternion.Identity();\r\n                    const noScale = Vector3.One();\r\n\r\n                    // retrieve all the instance world matrix\r\n                    const matrix = babylonNode.thinInstanceGetWorldMatrices();\r\n\r\n                    const iwt = TmpVectors.Vector3[2];\r\n                    const iwr = TmpVectors.Quaternion[1];\r\n                    const iws = TmpVectors.Vector3[3];\r\n\r\n                    let hasAnyInstanceWorldTranslation = false;\r\n                    let hasAnyInstanceWorldRotation = false;\r\n                    let hasAnyInstanceWorldScale = false;\r\n\r\n                    // prepare temp buffers\r\n                    const translationBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n                    const rotationBuffer = new Float32Array(babylonNode.thinInstanceCount * 4);\r\n                    const scaleBuffer = new Float32Array(babylonNode.thinInstanceCount * 3);\r\n\r\n                    let i = 0;\r\n                    for (const m of matrix) {\r\n                        m.decompose(iws, iwr, iwt);\r\n\r\n                        if (convertToRightHanded) {\r\n                            ConvertToRightHandedPosition(iwt);\r\n                            ConvertToRightHandedRotation(iwr);\r\n                        }\r\n\r\n                        // fill the temp buffer\r\n                        translationBuffer.set(iwt.asArray(), i * 3);\r\n                        rotationBuffer.set(iwr.normalize().asArray(), i * 4); // ensure the quaternion is normalized\r\n                        scaleBuffer.set(iws.asArray(), i * 3);\r\n\r\n                        // this is where we decide if there is any transformation\r\n                        hasAnyInstanceWorldTranslation = hasAnyInstanceWorldTranslation || !iwt.equalsWithEpsilon(noTranslation);\r\n                        hasAnyInstanceWorldRotation = hasAnyInstanceWorldRotation || !iwr.equalsWithEpsilon(noRotation);\r\n                        hasAnyInstanceWorldScale = hasAnyInstanceWorldScale || !iws.equalsWithEpsilon(noScale);\r\n\r\n                        i++;\r\n                    }\r\n\r\n                    const extension: IEXTMeshGpuInstancing = {\r\n                        attributes: {},\r\n                    };\r\n\r\n                    // do we need to write TRANSLATION ?\r\n                    if (hasAnyInstanceWorldTranslation) {\r\n                        extension.attributes[\"TRANSLATION\"] = this._buildAccessor(translationBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write ROTATION ?\r\n                    if (hasAnyInstanceWorldRotation) {\r\n                        // we decided to stay on FLOAT for now see https://github.com/BabylonJS/Babylon.js/pull/12495\r\n                        extension.attributes[\"ROTATION\"] = this._buildAccessor(rotationBuffer, AccessorType.VEC4, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n                    // do we need to write SCALE ?\r\n                    if (hasAnyInstanceWorldScale) {\r\n                        extension.attributes[\"SCALE\"] = this._buildAccessor(scaleBuffer, AccessorType.VEC3, babylonNode.thinInstanceCount, bufferManager);\r\n                    }\r\n\r\n                    /* eslint-enable @typescript-eslint/naming-convention*/\r\n                    node.extensions = node.extensions || {};\r\n                    node.extensions[NAME] = extension;\r\n                }\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n\r\n    private _buildAccessor(buffer: Float32Array, type: AccessorType, count: number, bufferManager: BufferManager): number {\r\n        // build the buffer view\r\n        const bv = bufferManager.createBufferView(buffer);\r\n\r\n        // finally build the accessor\r\n        const accessor = bufferManager.createAccessor(bv, type, AccessorComponentType.FLOAT, count);\r\n        this._exporter._accessors.push(accessor);\r\n        return this._exporter._accessors.length - 1;\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_mesh_gpu_instancing(exporter));\r\n","import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\nimport { GLTFExporter } from \"../glTFExporter\";\nimport { MeshPrimitiveMode } from \"babylonjs-gltf2interface\";\nimport type { IAccessor, IBufferView, IKHRDracoMeshCompression, IMeshPrimitive } from \"babylonjs-gltf2interface\";\nimport type { BufferManager } from \"../bufferManager\";\nimport { DracoEncoder } from \"core/Meshes/Compression/dracoEncoder\";\nimport { GetTypedArrayData, GetTypeByteLength } from \"core/Buffers/bufferUtils\";\nimport { GetAccessorElementCount } from \"../glTFUtilities\";\nimport type { DracoAttributeName, IDracoAttributeData, IDracoEncoderOptions } from \"core/Meshes/Compression/dracoEncoder.types\";\nimport { Logger } from \"core/Misc/logger\";\nimport type { Nullable } from \"core/types\";\n\nconst NAME = \"KHR_draco_mesh_compression\";\n\nfunction GetDracoAttributeName(glTFName: string): DracoAttributeName {\n    if (glTFName === \"POSITION\") {\n        return \"POSITION\";\n    } else if (glTFName === \"NORMAL\") {\n        return \"NORMAL\";\n    } else if (glTFName.startsWith(\"COLOR\")) {\n        return \"COLOR\";\n    } else if (glTFName.startsWith(\"TEXCOORD\")) {\n        return \"TEX_COORD\";\n    }\n    return \"GENERIC\";\n}\n\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class KHR_draco_mesh_compression implements IGLTFExporterExtensionV2 {\n    /** Name of this extension */\n    public readonly name = NAME;\n\n    /** Defines whether this extension is enabled */\n    public enabled;\n\n    /** KHR_draco_mesh_compression is required, as uncompressed fallback data is not yet implemented. */\n    public required = true;\n\n    /** BufferViews used for Draco data, which may be eligible for removal after Draco encoding */\n    private _bufferViewsUsed: Set<IBufferView> = new Set();\n\n    /** Accessors that were replaced with Draco data, which may be eligible for removal after Draco encoding */\n    private _accessorsUsed: Set<IAccessor> = new Set();\n\n    /** Promise pool for Draco encoding work */\n    private _encodePromises: Promise<void>[] = [];\n\n    private _wasUsed = false;\n\n    /** @internal */\n    public get wasUsed() {\n        return this._wasUsed;\n    }\n\n    /** @internal */\n    constructor(exporter: GLTFExporter) {\n        this.enabled = exporter.options.meshCompressionMethod === \"Draco\" && DracoEncoder.DefaultAvailable;\n    }\n\n    /** @internal */\n    public dispose() {}\n\n    /** @internal */\n    public postExportMeshPrimitive(primitive: IMeshPrimitive, bufferManager: BufferManager, accessors: IAccessor[]): void {\n        if (!this.enabled) {\n            return;\n        }\n\n        if (primitive.mode !== MeshPrimitiveMode.TRIANGLES && primitive.mode !== MeshPrimitiveMode.TRIANGLE_STRIP) {\n            Logger.Warn(\"Cannot compress primitive with mode \" + primitive.mode + \".\");\n            return;\n        }\n\n        // Collect bufferViews and accessors used by this primitive\n        const primitiveBufferViews: IBufferView[] = [];\n        const primitiveAccessors: IAccessor[] = [];\n\n        // Prepare indices for Draco encoding\n        let indices: Nullable<Uint32Array | Uint16Array> = null;\n        if (primitive.indices !== undefined) {\n            const accessor = accessors[primitive.indices];\n            const bufferView = bufferManager.getBufferView(accessor);\n            // Per exportIndices, indices must be either Uint16Array or Uint32Array\n            indices = bufferManager.getData(bufferView).slice() as Uint32Array | Uint16Array;\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Prepare attributes for Draco encoding\n        const attributes: IDracoAttributeData[] = [];\n        for (const [name, accessorIndex] of Object.entries(primitive.attributes)) {\n            const accessor = accessors[accessorIndex];\n            const bufferView = bufferManager.getBufferView(accessor);\n\n            const size = GetAccessorElementCount(accessor.type);\n            const data = GetTypedArrayData(\n                bufferManager.getData(bufferView),\n                size,\n                accessor.componentType,\n                accessor.byteOffset || 0,\n                bufferView.byteStride || GetTypeByteLength(accessor.componentType) * size,\n                accessor.normalized || false,\n                accessor.count,\n                true\n            );\n\n            attributes.push({ kind: name, dracoName: GetDracoAttributeName(name), size: GetAccessorElementCount(accessor.type), data: data });\n\n            primitiveBufferViews.push(bufferView);\n            primitiveAccessors.push(accessor);\n        }\n\n        // Use sequential encoding to preserve vertex order for cases like morph targets\n        const options: IDracoEncoderOptions = {\n            method: primitive.targets ? \"MESH_SEQUENTIAL_ENCODING\" : \"MESH_EDGEBREAKER_ENCODING\",\n        };\n\n        const promise = DracoEncoder.Default._encodeAsync(attributes, indices, options)\n            // eslint-disable-next-line github/no-then\n            .then((encodedData) => {\n                if (!encodedData) {\n                    Logger.Error(\"Draco encoding failed for primitive.\");\n                    return;\n                }\n\n                const dracoInfo: IKHRDracoMeshCompression = {\n                    bufferView: -1, // bufferView will be set to a real index later, when we write the binary and decide bufferView ordering\n                    attributes: encodedData.attributeIds,\n                };\n                const bufferView = bufferManager.createBufferView(encodedData.data);\n                bufferManager.setBufferView(dracoInfo, bufferView);\n\n                for (const bufferView of primitiveBufferViews) {\n                    this._bufferViewsUsed.add(bufferView);\n                }\n                for (const accessor of primitiveAccessors) {\n                    this._accessorsUsed.add(accessor);\n                }\n\n                primitive.extensions ||= {};\n                primitive.extensions[NAME] = dracoInfo;\n            })\n            // eslint-disable-next-line github/no-then\n            .catch((error) => {\n                Logger.Error(\"Draco encoding failed for primitive: \" + error);\n            });\n\n        this._encodePromises.push(promise);\n\n        this._wasUsed = true;\n    }\n\n    /** @internal */\n    public async preGenerateBinaryAsync(bufferManager: BufferManager): Promise<void> {\n        if (!this.enabled) {\n            return;\n        }\n\n        await Promise.all(this._encodePromises);\n\n        // Cull obsolete bufferViews that were replaced with Draco data\n        this._bufferViewsUsed.forEach((bufferView) => {\n            const references = bufferManager.getPropertiesWithBufferView(bufferView);\n            const onlyUsedByEncodedPrimitives = references.every((object) => {\n                return this._accessorsUsed.has(object as IAccessor); // has() can handle any object, but TS doesn't know that\n            });\n            if (onlyUsedByEncodedPrimitives) {\n                bufferManager.removeBufferView(bufferView);\n            }\n        });\n\n        this._bufferViewsUsed.clear();\n        this._accessorsUsed.clear();\n    }\n}\n\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_draco_mesh_compression(exporter));\n","import type { SpotLight } from \"core/Lights/spotLight\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { Vector3, Quaternion, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Light } from \"core/Lights/light\";\r\nimport type { Node } from \"core/node\";\r\nimport { ShadowLight } from \"core/Lights/shadowLight\";\r\nimport type { INode, IKHRLightsPunctual_LightReference, IKHRLightsPunctual_Light, IKHRLightsPunctual } from \"babylonjs-gltf2interface\";\r\nimport { KHRLightsPunctual_LightType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport { ConvertToRightHandedPosition, OmitDefaultValues, CollapseChildIntoParent, IsChildCollapsible } from \"../glTFUtilities\";\r\n\r\nconst NAME = \"KHR_lights_punctual\";\r\nconst DEFAULTS: Omit<IKHRLightsPunctual_Light, \"type\"> = {\r\n    name: \"\",\r\n    color: [1, 1, 1],\r\n    intensity: 1,\r\n    range: Number.MAX_VALUE,\r\n};\r\nconst SPOTDEFAULTS: NonNullable<IKHRLightsPunctual_Light[\"spot\"]> = {\r\n    innerConeAngle: 0,\r\n    outerConeAngle: Math.PI / 4.0,\r\n};\r\nconst LIGHTDIRECTION = Vector3.Backward();\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_lights_punctual/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_lights_punctual implements IGLTFExporterExtensionV2 {\r\n    /** The name of this extension. */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled. */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _lights: IKHRLightsPunctual;\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** @internal */\r\n    public dispose() {\r\n        (this._lights as any) = null;\r\n    }\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return !!this._lights;\r\n    }\r\n\r\n    /** @internal */\r\n    public onExporting(): void {\r\n        this._exporter._glTF.extensions![NAME] = this._lights;\r\n    }\r\n    /**\r\n     * Define this method to modify the default behavior when exporting a node\r\n     * @param context The context when exporting the node\r\n     * @param node glTF node\r\n     * @param babylonNode BabylonJS node\r\n     * @param nodeMap Node mapping of babylon node to glTF node index\r\n     * @param convertToRightHanded Flag to convert the values to right-handed\r\n     * @returns nullable INode promise\r\n     */\r\n    public async postExportNodeAsync(context: string, node: INode, babylonNode: Node, nodeMap: Map<Node, number>, convertToRightHanded: boolean): Promise<Nullable<INode>> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonNode instanceof Light)) {\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            const lightType =\r\n                babylonNode.getTypeID() == Light.LIGHTTYPEID_POINTLIGHT\r\n                    ? KHRLightsPunctual_LightType.POINT\r\n                    : babylonNode.getTypeID() == Light.LIGHTTYPEID_DIRECTIONALLIGHT\r\n                      ? KHRLightsPunctual_LightType.DIRECTIONAL\r\n                      : babylonNode.getTypeID() == Light.LIGHTTYPEID_SPOTLIGHT\r\n                        ? KHRLightsPunctual_LightType.SPOT\r\n                        : null;\r\n            if (!lightType || !(babylonNode instanceof ShadowLight)) {\r\n                Logger.Warn(`${context}: Light ${babylonNode.name} is not supported in ${NAME}`);\r\n                resolve(node);\r\n                return;\r\n            }\r\n\r\n            if (babylonNode.falloffType !== Light.FALLOFF_GLTF) {\r\n                Logger.Warn(`${context}: Light falloff for ${babylonNode.name} does not match the ${NAME} specification!`);\r\n            }\r\n\r\n            // Set the node's translation and rotation here, since lights are not handled in exportNodeAsync\r\n            if (!babylonNode.position.equalsToFloats(0, 0, 0)) {\r\n                const translation = TmpVectors.Vector3[0].copyFrom(babylonNode.position);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(translation);\r\n                }\r\n                node.translation = translation.asArray();\r\n            }\r\n\r\n            // Represent the Babylon light's direction as a quaternion\r\n            // relative to glTF lights' forward direction, (0, 0, -1).\r\n            if (lightType !== KHRLightsPunctual_LightType.POINT) {\r\n                const direction = babylonNode.direction.normalizeToRef(TmpVectors.Vector3[0]);\r\n                if (convertToRightHanded) {\r\n                    ConvertToRightHandedPosition(direction);\r\n                }\r\n\r\n                const lightRotationQuaternion = Quaternion.FromUnitVectorsToRef(LIGHTDIRECTION, direction, TmpVectors.Quaternion[0]);\r\n                if (!Quaternion.IsIdentity(lightRotationQuaternion)) {\r\n                    node.rotation = lightRotationQuaternion.asArray();\r\n                }\r\n            }\r\n\r\n            const light: IKHRLightsPunctual_Light = {\r\n                type: lightType,\r\n                name: babylonNode.name,\r\n                color: babylonNode.diffuse.asArray(),\r\n                intensity: babylonNode.intensity,\r\n                range: babylonNode.range,\r\n            };\r\n            OmitDefaultValues(light, DEFAULTS);\r\n\r\n            // Separately handle the required 'spot' field for spot lights\r\n            if (lightType === KHRLightsPunctual_LightType.SPOT) {\r\n                const babylonSpotLight = babylonNode as SpotLight;\r\n                light.spot = {\r\n                    innerConeAngle: babylonSpotLight.innerAngle / 2.0,\r\n                    outerConeAngle: babylonSpotLight.angle / 2.0,\r\n                };\r\n                OmitDefaultValues(light.spot, SPOTDEFAULTS);\r\n            }\r\n\r\n            this._lights ||= {\r\n                lights: [],\r\n            };\r\n            this._lights.lights.push(light);\r\n\r\n            const lightReference: IKHRLightsPunctual_LightReference = {\r\n                light: this._lights.lights.length - 1,\r\n            };\r\n\r\n            // Assign the light to its parent node, if possible, to condense the glTF\r\n            // Why and when: the glTF loader generates a new parent TransformNode for each light node, which we should undo on export\r\n            const parentBabylonNode = babylonNode.parent;\r\n\r\n            if (parentBabylonNode && IsChildCollapsible(babylonNode, parentBabylonNode)) {\r\n                const parentNodeIndex = nodeMap.get(parentBabylonNode);\r\n                if (parentNodeIndex) {\r\n                    // Combine the light's transformation with the parent's\r\n                    const parentNode = this._exporter._nodes[parentNodeIndex];\r\n                    CollapseChildIntoParent(node, parentNode);\r\n                    parentNode.extensions ||= {};\r\n                    parentNode.extensions[NAME] = lightReference;\r\n\r\n                    // Do not export the original node\r\n                    resolve(null);\r\n                    return;\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = lightReference;\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_lights_punctual(exporter));\r\n","import type { IMaterial, IKHRMaterialsAnisotropy } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_anisotropy\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_anisotropy implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.anisotropy.isEnabled && !babylonMaterial.anisotropy.legacy) {\r\n                if (babylonMaterial.anisotropy.texture) {\r\n                    additionalTextures.push(babylonMaterial.anisotropy.texture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.anisotropy.isEnabled || babylonMaterial.anisotropy.legacy) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const anisotropyTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.anisotropy.texture);\r\n\r\n                const anisotropyInfo: IKHRMaterialsAnisotropy = {\r\n                    anisotropyStrength: babylonMaterial.anisotropy.intensity,\r\n                    anisotropyRotation: babylonMaterial.anisotropy.angle,\r\n                    anisotropyTexture: anisotropyTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (anisotropyInfo.anisotropyTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = anisotropyInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_anisotropy(exporter));\r\n","import type { IMaterial, IKHRMaterialsClearcoat } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nimport { Tools } from \"core/Misc/tools\";\r\n\r\nconst NAME = \"KHR_materials_clearcoat\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_clearcoat implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.clearCoat.isEnabled) {\r\n                if (babylonMaterial.clearCoat.texture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.texture);\r\n                }\r\n                if (!babylonMaterial.clearCoat.useRoughnessFromMainTexture && babylonMaterial.clearCoat.textureRoughness) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n                if (babylonMaterial.clearCoat.bumpTexture) {\r\n                    additionalTextures.push(babylonMaterial.clearCoat.bumpTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.clearCoat.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const clearCoatTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                let clearCoatTextureRoughnessInfo;\r\n                if (babylonMaterial.clearCoat.useRoughnessFromMainTexture) {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.texture);\r\n                } else {\r\n                    clearCoatTextureRoughnessInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.textureRoughness);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.isTintEnabled) {\r\n                    Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                if (babylonMaterial.clearCoat.remapF0OnInterfaceChange) {\r\n                    Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${babylonMaterial.name}`);\r\n                }\r\n\r\n                const clearCoatNormalTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.clearCoat.bumpTexture);\r\n\r\n                const clearCoatInfo: IKHRMaterialsClearcoat = {\r\n                    clearcoatFactor: babylonMaterial.clearCoat.intensity,\r\n                    clearcoatTexture: clearCoatTextureInfo ?? undefined,\r\n                    clearcoatRoughnessFactor: babylonMaterial.clearCoat.roughness,\r\n                    clearcoatRoughnessTexture: clearCoatTextureRoughnessInfo ?? undefined,\r\n                    clearcoatNormalTexture: clearCoatNormalTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (clearCoatInfo.clearcoatTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null || clearCoatInfo.clearcoatRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = clearCoatInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_clearcoat(exporter));\r\n","import type { IMaterial, IKHRMaterialsDiffuseTransmission } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\nconst NAME = \"KHR_materials_diffuse_transmission\";\r\n\r\n/**\r\n * Get the appropriate translucency intensity texture for the material.\r\n * @internal\r\n */\r\nfunction GetTranslucencyIntensityTexture(context: string, babylonMaterial: PBRMaterial): Nullable<BaseTexture> {\r\n    const subs = babylonMaterial.subSurface;\r\n    let texture = null;\r\n\r\n    // Check if translucency intensity texture is available or can be derived from thickness texture\r\n    if (subs.translucencyIntensityTexture) {\r\n        texture = subs.translucencyIntensityTexture;\r\n    } else if (subs.thicknessTexture && subs.useMaskFromThicknessTexture) {\r\n        texture = subs.thicknessTexture;\r\n    }\r\n\r\n    if (texture && !subs.useGltfStyleTextures) {\r\n        Logger.Warn(`${context}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${babylonMaterial.name}`, 1);\r\n        return null;\r\n    }\r\n\r\n    return texture;\r\n}\r\n\r\n/**\r\n * [Proposed Specification](https://github.com/KhronosGroup/glTF/pull/1825)\r\n * !!! Experimental Extension Subject to Changes !!!\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_diffuse_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n            if (translucencyIntensityTexture) {\r\n                additionalTextures.push(translucencyIntensityTexture);\r\n            }\r\n            if (babylonMaterial.subSurface.translucencyColorTexture) {\r\n                additionalTextures.push(babylonMaterial.subSurface.translucencyColorTexture);\r\n            }\r\n            return additionalTextures;\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        if (!subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n\r\n        return (\r\n            !mat.unlit &&\r\n            !subs.useAlbedoToTintTranslucency &&\r\n            subs.useGltfStyleTextures &&\r\n            subs.volumeIndexOfRefraction === 1 &&\r\n            subs.minimumThickness === 0 &&\r\n            subs.maximumThickness === 0\r\n        );\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const translucencyIntensityTexture = GetTranslucencyIntensityTexture(context, babylonMaterial);\r\n\r\n                const diffuseTransmissionFactor = subs.translucencyIntensity == 0 ? undefined : subs.translucencyIntensity;\r\n                const diffuseTransmissionTexture = this._exporter._materialExporter.getTextureInfo(translucencyIntensityTexture) ?? undefined;\r\n                const diffuseTransmissionColorFactor = !subs.translucencyColor || subs.translucencyColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.translucencyColor.asArray();\r\n                const diffuseTransmissionColorTexture = this._exporter._materialExporter.getTextureInfo(subs.translucencyColorTexture) ?? undefined;\r\n\r\n                const diffuseTransmissionInfo: IKHRMaterialsDiffuseTransmission = {\r\n                    diffuseTransmissionFactor,\r\n                    diffuseTransmissionTexture,\r\n                    diffuseTransmissionColorFactor,\r\n                    diffuseTransmissionColorTexture,\r\n                };\r\n\r\n                if (diffuseTransmissionTexture || diffuseTransmissionColorTexture) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = diffuseTransmissionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_diffuse_transmission(exporter));\r\n","import type { IMaterial, IKHRMaterialsDispersion } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_dispersion\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/87bd64a7f5e23c84b6aef2e6082069583ed0ddb4/extensions/2.0/Khronos/KHR_materials_dispersion/README.md)\r\n * @experimental\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_dispersion implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Constructor */\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires refraction to be enabled.\r\n        if (!subs.isRefractionEnabled && !subs.isDispersionEnabled) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const dispersion = subs.dispersion;\r\n\r\n                const dispersionInfo: IKHRMaterialsDispersion = {\r\n                    dispersion: dispersion,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = dispersionInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_dispersion());\r\n","import type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { IMaterial, IKHRMaterialsEmissiveStrength } from \"babylonjs-gltf2interface\";\r\n\r\nconst NAME = \"KHR_materials_emissive_strength\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_emissive_strength/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_emissive_strength implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (!(babylonMaterial instanceof PBRMaterial)) {\r\n                return resolve(node);\r\n            }\r\n\r\n            const emissiveColor = babylonMaterial.emissiveColor.asArray();\r\n            const tempEmissiveStrength = Math.max(...emissiveColor);\r\n\r\n            if (tempEmissiveStrength > 1) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions ||= {};\r\n\r\n                const emissiveStrengthInfo: IKHRMaterialsEmissiveStrength = {\r\n                    emissiveStrength: tempEmissiveStrength,\r\n                };\r\n\r\n                // Normalize each value of the emissive factor to have a max value of 1\r\n                const newEmissiveFactor = babylonMaterial.emissiveColor.scale(1 / emissiveStrengthInfo.emissiveStrength);\r\n\r\n                node.emissiveFactor = newEmissiveFactor.asArray();\r\n                node.extensions[NAME] = emissiveStrengthInfo;\r\n            }\r\n\r\n            return resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_emissive_strength());\r\n","import type { IMaterial, IKHRMaterialsIor } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\n\r\nconst NAME = \"KHR_materials_ior\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_ior/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_ior implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return mat.indexOfRefraction != undefined && mat.indexOfRefraction != 1.5; // 1.5 is normative default value.\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const iorInfo: IKHRMaterialsIor = {\r\n                    ior: babylonMaterial.indexOfRefraction,\r\n                };\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = iorInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_ior());\r\n","import type { IMaterial, IKHRMaterialsIridescence } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_iridescence\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_iridescence implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial.iridescence.isEnabled) {\r\n                if (babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.texture);\r\n                }\r\n                if (babylonMaterial.iridescence.thicknessTexture && babylonMaterial.iridescence.thicknessTexture !== babylonMaterial.iridescence.texture) {\r\n                    additionalTextures.push(babylonMaterial.iridescence.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial.iridescence.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const iridescenceTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.texture);\r\n                const iridescenceThicknessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial.iridescence.thicknessTexture);\r\n\r\n                const iridescenceInfo: IKHRMaterialsIridescence = {\r\n                    iridescenceFactor: babylonMaterial.iridescence.intensity,\r\n                    iridescenceIor: babylonMaterial.iridescence.indexOfRefraction,\r\n                    iridescenceThicknessMinimum: babylonMaterial.iridescence.minimumThickness,\r\n                    iridescenceThicknessMaximum: babylonMaterial.iridescence.maximumThickness,\r\n\r\n                    iridescenceTexture: iridescenceTextureInfo ?? undefined,\r\n                    iridescenceThicknessTexture: iridescenceThicknessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (iridescenceInfo.iridescenceTexture !== null || iridescenceInfo.iridescenceThicknessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = iridescenceInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_iridescence(exporter));\r\n","import type { IMaterial, IKHRMaterialsSheen } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_sheen\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_sheen implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (babylonMaterial.sheen.isEnabled && babylonMaterial.sheen.texture) {\r\n                return [babylonMaterial.sheen.texture];\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    public async postExportMaterialAsync(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return await new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                if (!babylonMaterial.sheen.isEnabled) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n                const sheenInfo: IKHRMaterialsSheen = {\r\n                    sheenColorFactor: babylonMaterial.sheen.color.asArray(),\r\n                    sheenRoughnessFactor: babylonMaterial.sheen.roughness ?? 0,\r\n                };\r\n\r\n                if (sheenInfo.sheenColorTexture !== null || sheenInfo.sheenRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                if (babylonMaterial.sheen.texture) {\r\n                    sheenInfo.sheenColorTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                if (babylonMaterial.sheen.textureRoughness && !babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.textureRoughness) ?? undefined;\r\n                } else if (babylonMaterial.sheen.texture && babylonMaterial.sheen.useRoughnessFromMainTexture) {\r\n                    sheenInfo.sheenRoughnessTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.sheen.texture) ?? undefined;\r\n                }\r\n\r\n                node.extensions[NAME] = sheenInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_sheen(exporter));\r\n","import type { IMaterial, IKHRMaterialsSpecular } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"KHR_materials_specular\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_specular/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_specular implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with the additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.metallicReflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.metallicReflectanceTexture);\r\n                }\r\n                if (babylonMaterial.reflectanceTexture) {\r\n                    additionalTextures.push(babylonMaterial.reflectanceTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        return (\r\n            (mat.metallicF0Factor != undefined && mat.metallicF0Factor != 1.0) ||\r\n            (mat.metallicReflectanceColor != undefined && !mat.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.metallicReflectanceTexture != null || mat.reflectanceTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise, resolves with the material\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const metallicReflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.metallicReflectanceTexture) ?? undefined;\r\n                const reflectanceTexture = this._exporter._materialExporter.getTextureInfo(babylonMaterial.reflectanceTexture) ?? undefined;\r\n                const metallicF0Factor = babylonMaterial.metallicF0Factor == 1.0 ? undefined : babylonMaterial.metallicF0Factor;\r\n                const metallicReflectanceColor = babylonMaterial.metallicReflectanceColor.equalsFloats(1.0, 1.0, 1.0)\r\n                    ? undefined\r\n                    : babylonMaterial.metallicReflectanceColor.asArray();\r\n\r\n                const specularInfo: IKHRMaterialsSpecular = {\r\n                    specularFactor: metallicF0Factor,\r\n                    specularTexture: metallicReflectanceTexture,\r\n                    specularColorFactor: metallicReflectanceColor,\r\n                    specularColorTexture: reflectanceTexture,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = specularInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_specular(exporter));\r\n","import type { IMaterial, IKHRMaterialsTransmission } from \"babylonjs-gltf2interface\";\r\nimport { ImageMimeType } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Logger } from \"core/Misc/logger\";\r\n\r\nconst NAME = \"KHR_materials_transmission\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_transmission/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_transmission implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    /** Dispose */\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        return (subs.isRefractionEnabled && subs.refractionIntensity != undefined && subs.refractionIntensity != 0) || this._hasTexturesExtension(mat);\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.refractionIntensityTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns true if successful\r\n     */\r\n    public async postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n            this._wasUsed = true;\r\n\r\n            const subSurface = babylonMaterial.subSurface;\r\n            const transmissionFactor = subSurface.refractionIntensity === 0 ? undefined : subSurface.refractionIntensity;\r\n\r\n            const volumeInfo: IKHRMaterialsTransmission = {\r\n                transmissionFactor: transmissionFactor,\r\n            };\r\n\r\n            if (this._hasTexturesExtension(babylonMaterial)) {\r\n                this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n            }\r\n\r\n            if (subSurface.refractionIntensityTexture) {\r\n                if (subSurface.useGltfStyleTextures) {\r\n                    const transmissionTexture = await this._exporter._materialExporter.exportTextureAsync(subSurface.refractionIntensityTexture, ImageMimeType.PNG);\r\n                    if (transmissionTexture) {\r\n                        volumeInfo.transmissionTexture = transmissionTexture;\r\n                    }\r\n                } else {\r\n                    Logger.Warn(`${context}: Exporting a subsurface refraction intensity texture without \\`useGltfStyleTextures\\` is not supported`);\r\n                }\r\n            }\r\n\r\n            node.extensions ||= {};\r\n            node.extensions[NAME] = volumeInfo;\r\n        }\r\n\r\n        return node;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_transmission(exporter));\r\n","import type { IMaterial } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\r\n\r\nconst NAME = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_unlit implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            let unlitMaterial = false;\r\n\r\n            if (babylonMaterial instanceof PBRMaterial) {\r\n                unlitMaterial = babylonMaterial.unlit;\r\n            } else if (babylonMaterial instanceof StandardMaterial) {\r\n                unlitMaterial = babylonMaterial.disableLighting;\r\n            }\r\n\r\n            if (unlitMaterial) {\r\n                this._wasUsed = true;\r\n\r\n                if (node.extensions == null) {\r\n                    node.extensions = {};\r\n                }\r\n\r\n                node.extensions[NAME] = {};\r\n            }\r\n\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_materials_unlit());\r\n","import type { IMaterial, IKHRMaterialsVolume } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRMaterial } from \"core/Materials/PBR/pbrMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\n\r\nconst NAME = \"KHR_materials_volume\";\r\n\r\n/**\r\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_volume/README.md)\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_materials_volume implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material, deal with additional textures\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns array of additional textures to export\r\n     */\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n\r\n        if (babylonMaterial instanceof PBRMaterial) {\r\n            if (this._isExtensionEnabled(babylonMaterial)) {\r\n                if (babylonMaterial.subSurface.thicknessTexture) {\r\n                    additionalTextures.push(babylonMaterial.subSurface.thicknessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return additionalTextures;\r\n    }\r\n\r\n    private _isExtensionEnabled(mat: PBRMaterial): boolean {\r\n        // This extension must not be used on a material that also uses KHR_materials_unlit\r\n        if (mat.unlit) {\r\n            return false;\r\n        }\r\n        const subs = mat.subSurface;\r\n        // this extension requires either the KHR_materials_transmission or KHR_materials_diffuse_transmission extensions.\r\n        if (!subs.isRefractionEnabled && !subs.isTranslucencyEnabled) {\r\n            return false;\r\n        }\r\n        return (\r\n            (subs.maximumThickness != undefined && subs.maximumThickness != 0) ||\r\n            (subs.tintColorAtDistance != undefined && subs.tintColorAtDistance != Number.POSITIVE_INFINITY) ||\r\n            (subs.tintColor != undefined && subs.tintColor != Color3.White()) ||\r\n            this._hasTexturesExtension(mat)\r\n        );\r\n    }\r\n\r\n    private _hasTexturesExtension(mat: PBRMaterial): boolean {\r\n        return mat.subSurface.thicknessTexture != null;\r\n    }\r\n\r\n    /**\r\n     * After exporting a material\r\n     * @param context GLTF context of the material\r\n     * @param node exported GLTF node\r\n     * @param babylonMaterial corresponding babylon material\r\n     * @returns promise that resolves with the updated node\r\n     */\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRMaterial && this._isExtensionEnabled(babylonMaterial)) {\r\n                this._wasUsed = true;\r\n\r\n                const subs = babylonMaterial.subSurface;\r\n                const thicknessFactor = subs.maximumThickness == 0 ? undefined : subs.maximumThickness;\r\n                const thicknessTexture = this._exporter._materialExporter.getTextureInfo(subs.thicknessTexture) ?? undefined;\r\n                const attenuationDistance = subs.tintColorAtDistance == Number.POSITIVE_INFINITY ? undefined : subs.tintColorAtDistance;\r\n                const attenuationColor = subs.tintColor.equalsFloats(1.0, 1.0, 1.0) ? undefined : subs.tintColor.asArray();\r\n\r\n                const volumeInfo: IKHRMaterialsVolume = {\r\n                    thicknessFactor: thicknessFactor,\r\n                    thicknessTexture: thicknessTexture,\r\n                    attenuationDistance: attenuationDistance,\r\n                    attenuationColor: attenuationColor,\r\n                };\r\n\r\n                if (this._hasTexturesExtension(babylonMaterial)) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions = node.extensions || {};\r\n                node.extensions[NAME] = volumeInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new KHR_materials_volume(exporter));\r\n","import type { IMaterial, IEXTMaterialsDiffuseRoughness } from \"babylonjs-gltf2interface\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\nimport type { Material } from \"core/Materials/material\";\r\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\r\nimport type { BaseTexture } from \"core/Materials/Textures/baseTexture\";\r\n\r\nconst NAME = \"EXT_materials_diffuse_roughness\";\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class EXT_materials_diffuse_roughness implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    private _exporter: GLTFExporter;\r\n\r\n    private _wasUsed = false;\r\n\r\n    constructor(exporter: GLTFExporter) {\r\n        this._exporter = exporter;\r\n    }\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportMaterialAdditionalTextures?(context: string, node: IMaterial, babylonMaterial: Material): BaseTexture[] {\r\n        const additionalTextures: BaseTexture[] = [];\r\n        if (babylonMaterial instanceof PBRBaseMaterial) {\r\n            if (babylonMaterial._baseDiffuseRoughness) {\r\n                if (babylonMaterial._baseDiffuseRoughnessTexture) {\r\n                    additionalTextures.push(babylonMaterial._baseDiffuseRoughnessTexture);\r\n                }\r\n                return additionalTextures;\r\n            }\r\n        }\r\n\r\n        return [];\r\n    }\r\n\r\n    // eslint-disable-next-line no-restricted-syntax\r\n    public postExportMaterialAsync?(context: string, node: IMaterial, babylonMaterial: Material): Promise<IMaterial> {\r\n        return new Promise((resolve) => {\r\n            if (babylonMaterial instanceof PBRBaseMaterial) {\r\n                if (!babylonMaterial._baseDiffuseRoughness) {\r\n                    resolve(node);\r\n                    return;\r\n                }\r\n\r\n                this._wasUsed = true;\r\n\r\n                node.extensions = node.extensions || {};\r\n\r\n                const diffuseRoughnessTextureInfo = this._exporter._materialExporter.getTextureInfo(babylonMaterial._baseDiffuseRoughnessTexture);\r\n\r\n                const diffuseRoughnessInfo: IEXTMaterialsDiffuseRoughness = {\r\n                    diffuseRoughnessFactor: babylonMaterial._baseDiffuseRoughness,\r\n                    diffuseRoughnessTexture: diffuseRoughnessTextureInfo ?? undefined,\r\n                };\r\n\r\n                if (diffuseRoughnessInfo.diffuseRoughnessTexture !== null) {\r\n                    this._exporter._materialNeedsUVsSet.add(babylonMaterial);\r\n                }\r\n\r\n                node.extensions[NAME] = diffuseRoughnessInfo;\r\n            }\r\n            resolve(node);\r\n        });\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, (exporter) => new EXT_materials_diffuse_roughness(exporter));\r\n","import type { ITextureInfo, IKHRTextureTransform } from \"babylonjs-gltf2interface\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IGLTFExporterExtensionV2 } from \"../glTFExporterExtension\";\r\nimport { GLTFExporter } from \"../glTFExporter\";\r\n\r\nconst NAME = \"KHR_texture_transform\";\r\n\r\n/**\r\n * Computes the adjusted offset for a rotation centered about the origin.\r\n * @internal\r\n */\r\nfunction AdjustOffsetForRotationCenter(babylonTexture: Texture): [number, number] {\r\n    const { uOffset, vOffset, uRotationCenter, vRotationCenter, uScale, vScale, wAng } = babylonTexture;\r\n    const cosAngle = Math.cos(wAng);\r\n    const sinAngle = Math.sin(wAng);\r\n    const scaledURotationCenter = uRotationCenter * uScale;\r\n    const scaledVRotationCenter = vRotationCenter * vScale;\r\n    const deltaU = scaledURotationCenter * (1 - cosAngle) + scaledVRotationCenter * sinAngle;\r\n    const deltaV = scaledVRotationCenter * (1 - cosAngle) - scaledURotationCenter * sinAngle;\r\n    return [uOffset + deltaU, vOffset + deltaV];\r\n}\r\n\r\n/**\r\n * @internal\r\n */\r\n// eslint-disable-next-line @typescript-eslint/naming-convention\r\nexport class KHR_texture_transform implements IGLTFExporterExtensionV2 {\r\n    /** Name of this extension */\r\n    public readonly name = NAME;\r\n\r\n    /** Defines whether this extension is enabled */\r\n    public enabled = true;\r\n\r\n    /** Defines whether this extension is required */\r\n    public required = false;\r\n\r\n    /** Reference to the glTF exporter */\r\n    private _wasUsed = false;\r\n\r\n    constructor() {}\r\n\r\n    public dispose() {}\r\n\r\n    /** @internal */\r\n    public get wasUsed() {\r\n        return this._wasUsed;\r\n    }\r\n\r\n    public postExportTexture?(context: string, textureInfo: ITextureInfo, babylonTexture: Texture): void {\r\n        const scene = babylonTexture.getScene();\r\n        if (!scene) {\r\n            Tools.Warn(`${context}: \"scene\" is not defined for Babylon texture ${babylonTexture.name}!`);\r\n        }\r\n\r\n        /*\r\n         * The KHR_texture_transform schema only supports w rotation around the origin.\r\n         * See https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_texture_transform#gltf-schema-updates.\r\n         */\r\n        if (babylonTexture.uAng !== 0 || babylonTexture.vAng !== 0) {\r\n            Tools.Warn(`${context}: Texture ${babylonTexture.name} with rotation in the u or v axis is not supported in glTF.`);\r\n            // Usually, we'd always early return here if the texture uses an unsupported combination of transform properties,\r\n            // but we're making an exception here to maintain backwards compatibility.\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        const textureTransform: IKHRTextureTransform = {};\r\n        let transformIsRequired = false;\r\n\r\n        if (babylonTexture.uOffset !== 0 || babylonTexture.vOffset !== 0) {\r\n            textureTransform.offset = [babylonTexture.uOffset, babylonTexture.vOffset];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.uScale !== 1 || babylonTexture.vScale !== 1) {\r\n            textureTransform.scale = [babylonTexture.uScale, babylonTexture.vScale];\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.wAng !== 0) {\r\n            if (babylonTexture.uRotationCenter !== 0 || babylonTexture.vRotationCenter !== 0) {\r\n                // See https://github.com/mrdoob/three.js/issues/15831 for more details.\r\n                if (babylonTexture.homogeneousRotationInUVTransform && babylonTexture.uScale !== babylonTexture.vScale) {\r\n                    Tools.Warn(\r\n                        `${context}: Texture ${babylonTexture.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${NAME}.`\r\n                    );\r\n                    return;\r\n                }\r\n                Tools.Warn(`${context}: Texture ${babylonTexture.name} with non-origin rotation center will be exported using an adjusted offset with ${NAME}.`);\r\n                textureTransform.offset = AdjustOffsetForRotationCenter(babylonTexture);\r\n            }\r\n            textureTransform.rotation = -babylonTexture.wAng;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (babylonTexture.coordinatesIndex !== 0) {\r\n            textureTransform.texCoord = babylonTexture.coordinatesIndex;\r\n            transformIsRequired = true;\r\n        }\r\n\r\n        if (!transformIsRequired) {\r\n            return;\r\n        }\r\n\r\n        this._wasUsed = true;\r\n        if (!textureInfo.extensions) {\r\n            textureInfo.extensions = {};\r\n        }\r\n        textureInfo.extensions[NAME] = textureTransform;\r\n    }\r\n}\r\n\r\nGLTFExporter.RegisterExtension(NAME, () => new KHR_texture_transform());\r\n","/* eslint-disable import/no-internal-modules */\r\nimport * as Exporters from \"serializers/glTF/glTFFileExporter\";\r\nimport * as Datas from \"serializers/glTF/2.0/glTFData\";\r\nimport * as Serializers from \"serializers/glTF/2.0/glTFSerializer\";\r\nimport * as Extensions from \"serializers/glTF/2.0/Extensions/index\";\r\nimport * as GLTF2 from \"serializers/glTF/2.0/index\";\r\n\r\n/**\r\n * This is the entry point for the UMD module.\r\n * The entry point for a future ESM package should be index.ts\r\n */\r\nconst globalObject = typeof global !== \"undefined\" ? global : typeof window !== \"undefined\" ? window : undefined;\r\nif (typeof globalObject !== \"undefined\") {\r\n    (<any>globalObject).BABYLON = (<any>globalObject).BABYLON || {};\r\n    const BABYLON = (<any>globalObject).BABYLON;\r\n    BABYLON.GLTF2 = BABYLON.GLTF2 || {};\r\n    BABYLON.GLTF2.Exporter = BABYLON.GLTF2.Exporter || {};\r\n    BABYLON.GLTF2.Exporter.Extensions = BABYLON.GLTF2.Exporter.Extensions || {};\r\n\r\n    const keys = [];\r\n    for (const key in Exporters) {\r\n        BABYLON[key] = (<any>Exporters)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Datas) {\r\n        BABYLON[key] = (<any>Datas)[key];\r\n        keys.push(key);\r\n    }\r\n    for (const key in Serializers) {\r\n        BABYLON[key] = (<any>Serializers)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in Extensions) {\r\n        BABYLON.GLTF2.Exporter.Extensions[key] = (<any>Extensions)[key];\r\n        keys.push(key);\r\n    }\r\n\r\n    for (const key in GLTF2) {\r\n        // Prevent Reassignment.\r\n        if (keys.indexOf(key) > -1) {\r\n            continue;\r\n        }\r\n\r\n        BABYLON.GLTF2.Exporter[key] = (<any>GLTF2)[key];\r\n    }\r\n}\r\n\r\nexport * from \"serializers/glTF/glTFFileExporter\";\r\nexport * from \"serializers/glTF/2.0/index\";\r\n","import * as serializers from \"@lts/serializers/legacy/legacy-glTF2Serializer\";\r\nexport { serializers };\r\nexport default serializers;\r\n"],"names":["root","factory","exports","module","require","define","amd","self","global","this","__WEBPACK_EXTERNAL_MODULE__597__","leafPrototypes","getProto","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","Object","getPrototypeOf","obj","t","value","mode","__esModule","then","ns","create","r","def","current","indexOf","getOwnPropertyNames","forEach","key","d","definition","o","defineProperty","enumerable","get","g","globalThis","Function","e","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","__IGLTFExporterExtension","files","downloadFiles","blob","Blob","type","GetMimeType","Tools","Download","__assign","assign","s","i","n","arguments","length","p","apply","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","rejected","result","done","__generator","body","f","y","_","label","sent","trys","ops","Iterator","verb","iterator","v","op","TypeError","pop","push","__spreadArray","to","from","pack","ar","l","Array","slice","concat","SuppressedError","Epsilon","DielectricSpecular","Color3","MaxSpecularPower","White","Black","_SolveMetallic","diffuse","specular","oneMinusSpecularStrength","a","b","Scalar","Clamp","Math","sqrt","_ConvertToGLTFPBRMetallicRoughness","babylonStandardMaterial","diffuseColor","toLinearSpace","getScene","getEngine","useExactSrgbConversions","scale","opacity","alpha","specularPower","roughness","SpecularPowerToRoughness","baseColorFactor","metallicFactor","roughnessFactor","SetAlphaMode","glTFMaterial","babylonMaterial","needAlphaBlending","alphaMode","needAlphaTesting","alphaCutoff","alphaCutOff","CreateWhiteTexture","width","height","scene","data","Uint8Array","RawTexture","CreateRGBATexture","ConvertPixelArrayToFloat32","pixels","buffer","Float32Array","Error","_exporter","_textureMap","Map","_internalTextureToImage","getTextureInfo","babylonTexture","exportStandardMaterialAsync","mimeType","hasUVs","pbrMetallicRoughness","material","name","backFaceCulling","twoSidedLighting","Warn","doubleSided","promises","diffuseTexture","exportTextureAsync","textureInfo","baseColorTexture","bumpTexture","normalTexture","level","emissiveTexture","emissiveFactor","ambientTexture","occlusionTexture","index","_materialNeedsUVsSet","add","all","opacityTexture","Constants","ALPHA_COMBINE","toString","emissiveColor","equalsWithEpsilon","asArray","_finishMaterialAsync","materials","_materials","textures","_extensionsPostExportMaterialAdditionalTextures","texture","_extensionsPostExportMaterialAsync","_getImageDataAsync","textureType","TEXTURETYPE_UNSIGNED_BYTE","hostingScene","_babylonScene","engine","tempTexture","createRawTexture","TEXTUREFORMAT_RGBA","Texture","NEAREST_SAMPLINGMODE","isWebGPU","TextureTools","ApplyPostProcess","TEXTURE_NEAREST_SAMPLINGMODE","_readTexturePixels","DumpTools","DumpDataAsync","_resizeTexturesToSameDimensions","texture1","texture2","resizedTexture1","resizedTexture2","texture1Size","getSize","texture2Size","CreateResizedCopy","_convertSpecularGlossinessTexturesToMetallicRoughnessAsync","specularGlossinessTexture","factors","resizedTextures","diffuseSize","diffuseBuffer","specularGlossinessBuffer","readPixels","diffusePixels","specularPixels","byteLength","metallicRoughnessBuffer","baseColorBuffer","maxBaseColor","maxMetallic","maxRoughness","h","w","offset","multiply","specularColor","glossiness","specularGlossiness","metallicRoughness","_convertSpecularGlossinessToMetallicRoughness","max","baseColor","metallic","hasAlpha","writeOutMetallicRoughnessTexture","writeOutBaseColorTexture","destinationOffset","linearBaseColorPixel","FromInts","sRGBBaseColorPixel","toGammaSpace","metallicRoughnessTextureData","baseColorTextureData","diffusePerceivedBrightness","_getPerceivedBrightness","specularPerceivedBrightness","_getMaxComponent","baseColorFromDiffuse","baseColorFromSpecular","subtract","Lerp","clampToRef","color","_convertMetalRoughFactorsToMetallicRoughnessAsync","babylonPBRMaterial","glTFPbrMetallicRoughness","_albedoColor","_metallic","_roughness","_albedoTexture","glTFTexture","metallicTexture","_metallicTexture","metallicRoughnessTexture","_getTextureSampler","sampler","wrapS","_getGLTFTextureWrapMode","wrapU","wrapT","wrapV","samplingMode","LINEAR_LINEAR","magFilter","minFilter","LINEAR_NEAREST","NEAREST_LINEAR","NEAREST_LINEAR_MIPLINEAR","NEAREST_NEAREST","NEAREST_LINEAR_MIPNEAREST","LINEAR_NEAREST_MIPNEAREST","LINEAR_NEAREST_MIPLINEAR","NEAREST_NEAREST_MIPLINEAR","LINEAR_LINEAR_MIPLINEAR","LINEAR_LINEAR_MIPNEAREST","NEAREST_NEAREST_MIPNEAREST","wrapMode","WRAP_ADDRESSMODE","CLAMP_ADDRESSMODE","MIRROR_ADDRESSMODE","_convertSpecGlossFactorsToMetallicRoughnessAsync","specGloss","_reflectivityColor","_microSurface","albedoTexture","reflectivityTexture","_reflectivityTexture","useMicrosurfaceFromReflectivityMapAlpha","_useMicroSurfaceFromReflectivityMapAlpha","samplerIndex","_exportTextureSampler","metallicRoughnessFactors","_textures","imageIndex","_exportImage","_exportTextureInfo","coordinatesIndex","exportPBRMaterialAsync","useMetallicRoughness","isMetallicWorkflow","albedoColor","_setMetallicRoughnessPbrMaterialAsync","WithinEpsilon","_twoSidedLighting","_bumpTexture","_ambientTexture","texCoord","extensions","ambientTextureStrength","_ambientTextureStrength","strength","_emissiveTexture","_emissiveColor","_getPixelsFromTextureAsync","format","TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM","TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM","TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT","TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5","TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3","TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1","TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1","TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT","TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT","TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4","TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR","TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL","TEXTUREFORMAT_COMPRESSED_RGB8_ETC2","TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2","TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2","TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2","TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC","TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC","IsCompressedTextureFormat","textureFormat","GetTextureDataAsync","_texture","extensionPromise","_extensionsPreExportTextureAsync","_exportTextureInfoAsync","textureMimeType","internalTextureToImage","internalTextureUniqueId","getInternalTexture","uniqueId","imageIndexPromise","set","_extensionsPostExportTextures","image","images","_images","_shouldUseGlb","bufferView","_bufferManager","createBufferView","setBufferView","baseName","replace","extension","GetFileExtensionFromMimeType","some","uri","RandomId","_imageData","textureIndex","findIndex","source","samplers","_samplers","ConvertHandednessMatrix","Matrix","Compose","Vector3","Quaternion","Identity","Zero","DefaultTranslation","DefaultRotation","DefaultScale","One","DefaultLoaderCameraParentScaleLh","GetVertexBufferInfo","vertexBuffer","meshes","byteOffset","byteStride","normalized","componentCount","totalVertices","reduce","getTotalVertices","Number","MAX_VALUE","count","kind","getKind","GetAccessorElementCount","accessorType","IsStandardVertexAttribute","VertexBuffer","PositionKind","NormalKind","TangentKind","ColorKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","GetPrimitiveMode","fillMode","Material","TriangleFillMode","TriangleStripDrawMode","TriangleFanDrawMode","PointListDrawMode","PointFillMode","LineLoopDrawMode","LineListDrawMode","LineStripDrawMode","NormalizeTangent","tangent","x","z","ConvertToRightHandedPosition","ConvertToRightHandedRotation","absX","abs","absY","sign","absZ","absW","Rotate180Y","rotation","copyFromFloats","CollapseChildIntoParent","node","parentNode","parentTranslation","FromArrayToRef","translation","TmpVectors","parentRotation","parentMatrix","ComposeToRef","matrix","multiplyToRef","decompose","IsChildCollapsible","babylonNode","parentBabylonNode","TransformNode","getChildren","parent","expectedScale","TargetCamera","useRightHandedSystem","scaling","Logger","IsNoopNode","getWorldMatrix","IdentityReadOnly","AbstractMesh","geometry","OmitDefaultValues","object","defaultValues","entries","defaultValue","isArray","AreArraysEqual","array1","array2","every","val","TypedArrayToWriteMethod","Int8Array","setInt8","dv","bo","setUint8","Uint8ClampedArray","Int16Array","setInt16","Uint16Array","setUint16","Int32Array","setInt32","Uint32Array","setUint32","setFloat32","Float64Array","setFloat64","_data","_dataView","DataView","_byteOffset","writeTypedArray","_checkGrowBuffer","setMethod","constructor","BYTES_PER_ELEMENT","getOutputData","writeUInt8","writeInt8","writeInt16","entry","writeUInt16","writeInt32","writeUInt32","writeFloat32","writeFloat64","newByteLength","newData","GetHighestByteAlignment","_TangentType","_bufferViewToData","_bufferViewToProperties","_accessorToBufferView","generateBinary","bufferViews","totalByteLength","dataWriter","DataWriter","keys","sort","bufferViewIndex","getPropertiesWithBufferView","delete","createAccessor","componentType","minMax","_verifyBufferView","accessor","min","removeBufferView","bv","getBufferView","getData","has","_IsTransformable","Camera","Light","_CreateNodeAnimation","babylonTransformNode","animation","animationChannelTargetPath","useQuaternion","animationSampleRate","inputs","outputs","keyFrames","getKeys","minMaxKeyFrames","_GLTFAnimation","_CalculateMinMaxKeyFrames","interpolationOrBake","_DeduceInterpolation","interpolation","interpolationType","shouldBakeAnimation","_CreateBakedAnimation","framePerSecond","_CreateLinearOrStepAnimation","_CreateCubicSplineAnimation","samplerInterpolation","inputsMin","FloatRound","inputsMax","_DeduceAnimationInfo","dataAccessorType","property","targetProperty","split","_CreateNodeAnimationFromNodeAnimations","runtimeGLTFAnimation","idleGLTFAnimations","nodeMap","nodes","bufferManager","accessors","useRightHanded","shouldExportAnimation","glTFAnimation","animations","animationInfo","channels","_AddAnimation","hasRunningRuntimeAnimations","_CreateMorphTargetAnimationFromMorphTargetAnimations","Mesh","morphTargetManager","numTargets","getTarget","combinedAnimation","Animation","dataType","loopMode","enableBlending","combinedAnimationKeys","animationKeys","j","animationKey","k","frame","setKeys","_CreateNodeAndMorphAnimationFromAnimationGroups","babylonScene","glTFAnimations","leftHandedNodes","animationGroups","animationGroup","morphAnimations","sampleAnimations","morphAnimationMeshes","Set","animationGroupFrameDiff","targetAnimation","targetedAnimations","target","convertToRightHanded","MorphTarget","morphTargetManagers","find","babylonMesh","mesh","combinedAnimationGroup","sampleAnimationKeys","numAnimationKeys","morphTarget","animationsByMorphTarget","morphTargetAnimation","ANIMATIONTYPE_FLOAT","influence","inTangent","outTangent","morphAnimationChannels","keyframeAccessorIndex","dataAccessorIndex","animationSampler","animationChannel","animationData","currentInput","newInputs","shift","nodeIndex","inputData","output","outputToWrite","toArray","FromEulerVectorToRef","input","path","minFrame","maxFrame","fps","sampleRate","minMaxFrames","time","quaternionCache","previousTime","maxUsedFrame","currKeyFrame","nextKeyFrame","prevKeyFrame","endFrame","equals","state","repeatCount","_interpolate","_SetInterpolatedValue","_ConvertFactorToVector3OrQuaternion","factor","basePositionRotationOrScale","_GetBasePositionRotationOrScale","componentName","FromArray","normalize","cacheValue","RotationYawPitchRollToRef","keyFrame","_AddKeyframeValue","_AddSplineTangent","INTANGENT","OUTTANGENT","q","rotationQuaternion","position","newPositionRotationOrScale","animationType","ANIMATIONTYPE_VECTOR3","array","RotationYawPitchRoll","posRotScale","ANIMATIONTYPE_QUATERNION","tangentType","tangentValue","Infinity","BuildMorphTargetBuffers","attributes","flipX","difference","vertexCount","hasPositions","morphPositions","getPositions","originalPositions","getVerticesData","positionData","originalPosition","subtractToRef","floatSize","hasNormals","morphNormals","getNormals","originalNormals","normalData","originalNormal","hasTangents","morphTangents","getTangents","originalTangents","tangentData","originalTangent","morphTangent","hasColors","morphColors","getColors","originalColors","getVertexBuffer","componentSize","colorData","originalColor","difference4","Vector4","wasAddedByNoopNode","_indicesAccessorMap","_vertexBufferViewMap","_vertexAccessorMap","_remappedBufferView","_meshMorphTargetMap","_vertexMapColorAlpha","_exportedNodes","_meshMap","convertedToRightHandedBuffers","getIndicesAccessor","indices","start","flip","setIndicesAccessor","accessorIndex","map1","map2","map3","map4","pushExportedNode","getNodesSet","getVertexBufferView","setVertexBufferView","setRemappedBufferView","getRemappedBufferView","getVertexAccessor","setVertexAccessor","hasVertexColorAlpha","setHasVertexColorAlpha","getMesh","setMesh","meshIndex","bindMorphDataToMesh","morphData","morphTargets","getMorphTargetsFromMesh","options","EngineStore","LastCreatedScene","_glTF","asset","Engine","Version","version","_animations","_accessors","_bufferViews","_cameras","_meshes","_nodes","_scenes","_skins","_materialExporter","GLTFMaterialExporter","_extensions","BufferManager","_shouldExportNodeMap","_nodeMap","_materialMap","_camerasMap","_nodesCameraMap","_skinMap","_nodesSkinMap","_options","shouldExportNode","metadataSelector","metadata","gltf","extras","exportWithoutWaitingForScene","exportUnusedUVs","removeNoopRootNodes","includeCoordinateSystemConversionNodes","meshCompressionMethod","_loadExtensions","_ApplyExtension","actionAsync","currentPromise","newNode","_ApplyExtensions","GLTFExporter","_ExtensionNames","context","preExportTextureAsync","_extensionsPostExportNodeAsync","postExportNodeAsync","postExportMaterialAsync","postExportMaterialAdditionalTextures","postExportTexture","_extensionsPostExportMeshPrimitive","primitive","postExportMeshPrimitive","_extensionsPreGenerateBinaryAsync","preGenerateBinaryAsync","_forEachExtensions","action","enabled","_extensionsOnExporting","wasUsed","extensionsUsed","required","extensionsRequired","onExporting","_ExtensionFactories","dispose","RegisterExtension","UnregisterExtension","splice","_generateJSON","bufferByteLength","fileName","prettyPrint","buffers","scenes","cameras","skins","JSON","stringify","generateGLTFAsync","glTFPrefix","_generateBinaryAsync","binaryBuffer","jsonText","bin","glTFFileName","glTFBinFile","container","GLTFData","_exportSceneAsync","_getPadding","num","remainder","generateGLBAsync","glbFileName","jsonLength","TextEncoder","encoder","encodedJsonText","encode","jsonPadding","binPadding","headerLength","headerBuffer","ArrayBuffer","headerBufferView","jsonChunkBuffer","jsonChunkBufferView","jsonData","blankCharCode","charCodeAt","charCode","codePointAt","jsonPaddingView","binaryChunkBuffer","binaryChunkBufferView","binPaddingBuffer","binPaddingView","glbFile","_setNodeTransformation","getPivotPoint","copyFrom","FromEulerAngles","_setCameraTransformation","babylonCamera","_listAvailableCameras","camera","glTFCamera","PERSPECTIVE_CAMERA","perspective","aspectRatio","getAspectRatio","yfov","fovMode","FOVMODE_VERTICAL_FIXED","fov","znear","minZ","zfar","maxZ","halfWidth","orthoLeft","orthoRight","getRenderWidth","halfHeight","orthoBottom","orthoTop","getRenderHeight","orthographic","xmag","ymag","_exportAndAssignCameras","values","gltfCamera","usedNodes","_listAvailableSkeletons","skeletons","skeleton","bones","joints","_exportAndAssignSkeletons","skin","boneIndexMap","inverseBindMatrices","maxBoneIndex","bone","boneIndex","getIndex","getAbsoluteInverseBindMatrix","transformNode","getTransformNode","nodeID","skinedNodes","mat","m","rootNodesRH","rootNodesLH","rootNoopNodesRH","rootNodes","rootNode","stateLH","ExporterState","_exportNodesAsync","stateRH","noopRH","_animationSampleRate","_shouldExportNode","babylonRootNodes","_exportBuffers","_exportNodeAsync","_collectBuffers","bufferToVertexBuffersMap","vertexBufferToMeshesMap","morphTargetsToMeshesMap","vertexBuffers","getVertexBuffers","hasVertexAlpha","_buffer","vertexBufferArray","morphIndex","babylonChildNode","morphTargetsMeshesMap","bytes","floatData","isView","DataArrayToUint8Array","EnumerateFloatValues","invLength","stdMaterialCount","filter","StandardMaterial","UNSIGNED_BYTE","Color4","fromArray","toLinearSpaceToRef","floatMatricesIndices","FLOAT","getFloatData","size","is16Bit","newArray","glTFMorphTarget","parentNodeChildren","includes","_createNodeAsync","idleGLTFAnimation","children","InstancedMesh","sourceMesh","subMeshes","_exportMeshAsync","parentNodeIndex","_exportIndices","is32Bits","sideOrientation","indicesToExport","invertedMaterial","CounterClockWiseSideOrientation","flipWhenInvertedMaterial","IsTriangleFillMode","newIndices","subarray","IndicesArrayToTypedArray","_exportVertexBuffer","startsWith","fill","GetMinMax","isFloatMatricesIndices","vertexBufferType","vertexBufferNormalized","GetAccessorType","GetAttributeType","_exportMaterialAsync","subMesh","materialIndex","MultiMaterial","subMaterials","PBRMaterial","getClassName","primitives","isUnIndexed","getIndices","isLinesMesh","LinesMesh","isGreasedLineMesh","GreasedLineBaseMesh","getMaterial","defaultMaterial","babylonLinesMesh","colorWhite","greasedLineMaterial","overrideRenderingFillMode","_getEffectiveOrientation","AreIndices32Bits","indexCount","indexStart","verticesStart","verticesCount","targets","gltfMorphTarget","weights","targetNames","GLTFAsync","whenReadyAsync","exporter","GLBAsync","NAME","_wasUsed","hasThinInstances","noTranslation","noRotation","noScale","thinInstanceGetWorldMatrices","iwt","iwr","iws","hasAnyInstanceWorldTranslation","hasAnyInstanceWorldRotation","hasAnyInstanceWorldScale","translationBuffer","thinInstanceCount","rotationBuffer","scaleBuffer","_buildAccessor","EXT_mesh_gpu_instancing","_bufferViewsUsed","_accessorsUsed","_encodePromises","DracoEncoder","DefaultAvailable","primitiveBufferViews","primitiveAccessors","glTFName","GetTypedArrayData","GetTypeByteLength","dracoName","method","promise","Default","_encodeAsync","encodedData","dracoInfo","attributeIds","catch","error","clear","KHR_draco_mesh_compression","DEFAULTS","intensity","range","SPOTDEFAULTS","innerConeAngle","outerConeAngle","PI","LIGHTDIRECTION","Backward","_lights","lightType","getTypeID","LIGHTTYPEID_POINTLIGHT","LIGHTTYPEID_DIRECTIONALLIGHT","LIGHTTYPEID_SPOTLIGHT","ShadowLight","falloffType","FALLOFF_GLTF","equalsToFloats","direction","normalizeToRef","lightRotationQuaternion","FromUnitVectorsToRef","IsIdentity","light","babylonSpotLight","spot","innerAngle","angle","lights","lightReference","KHR_lights_punctual","additionalTextures","PBRBaseMaterial","anisotropy","isEnabled","legacy","anisotropyTextureInfo","anisotropyInfo","anisotropyStrength","anisotropyRotation","anisotropyTexture","KHR_materials_anisotropy","clearCoat","useRoughnessFromMainTexture","textureRoughness","clearCoatTextureRoughnessInfo","clearCoatTextureInfo","isTintEnabled","remapF0OnInterfaceChange","clearCoatNormalTextureInfo","clearCoatInfo","clearcoatFactor","clearcoatTexture","clearcoatRoughnessFactor","clearcoatRoughnessTexture","clearcoatNormalTexture","KHR_materials_clearcoat","GetTranslucencyIntensityTexture","subs","subSurface","translucencyIntensityTexture","thicknessTexture","useMaskFromThicknessTexture","useGltfStyleTextures","_isExtensionEnabled","translucencyColorTexture","unlit","isTranslucencyEnabled","useAlbedoToTintTranslucency","volumeIndexOfRefraction","minimumThickness","maximumThickness","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","equalsFloats","diffuseTransmissionColorTexture","diffuseTransmissionInfo","KHR_materials_diffuse_transmission","isRefractionEnabled","isDispersionEnabled","dispersionInfo","dispersion","KHR_materials_dispersion","tempEmissiveStrength","emissiveStrengthInfo","emissiveStrength","newEmissiveFactor","KHR_materials_emissive_strength","indexOfRefraction","iorInfo","ior","KHR_materials_ior","iridescence","iridescenceTextureInfo","iridescenceThicknessTextureInfo","iridescenceInfo","iridescenceFactor","iridescenceIor","iridescenceThicknessMinimum","iridescenceThicknessMaximum","iridescenceTexture","iridescenceThicknessTexture","KHR_materials_iridescence","sheen","sheenInfo","sheenColorFactor","sheenRoughnessFactor","sheenColorTexture","sheenRoughnessTexture","KHR_materials_sheen","metallicReflectanceTexture","reflectanceTexture","metallicF0Factor","metallicReflectanceColor","_hasTexturesExtension","specularInfo","specularFactor","specularTexture","specularColorFactor","specularColorTexture","KHR_materials_specular","refractionIntensity","refractionIntensityTexture","transmissionFactor","volumeInfo","transmissionTexture","KHR_materials_transmission","unlitMaterial","disableLighting","KHR_materials_unlit","tintColorAtDistance","POSITIVE_INFINITY","tintColor","thicknessFactor","attenuationDistance","attenuationColor","KHR_materials_volume","_baseDiffuseRoughness","_baseDiffuseRoughnessTexture","diffuseRoughnessTextureInfo","diffuseRoughnessInfo","diffuseRoughnessFactor","diffuseRoughnessTexture","EXT_materials_diffuse_roughness","uAng","vAng","uRotationCenter","vRotationCenter","textureTransform","transformIsRequired","uOffset","vOffset","uScale","vScale","wAng","homogeneousRotationInUVTransform","cosAngle","cos","sinAngle","sin","scaledURotationCenter","scaledVRotationCenter","AdjustOffsetForRotationCenter","KHR_texture_transform","globalObject","BABYLON","GLTF2","Exporter","Extensions"],"sourceRoot":""}